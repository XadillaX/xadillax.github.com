
<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <title>一起撸Node.JS（壹）——基本语法和类型 :: 艾克斯の編碼者</title>
    <meta http-equiv=Content-Type content="text/html;charset=utf-8">
    
    <meta name="author" content="XadillaX">

    <!-- Enable responsive viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <script type="text/javascript" src="/assets/themes/graydiary/js/jquery-2.0.3.min.js"></script>
    <script type="text/javascript" src="/assets/themes/graydiary/js/main.js"></script>
    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link href='http://fonts.googleapis.com/css?family=Macondo' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Raleway' rel='stylesheet' type='text/css'>

    <link href="/assets/themes/graydiary/css/main.css" rel="stylesheet">
    <link href="/assets/themes/graydiary/css/syntax.css" type="text/css" rel="stylesheet" />
</head>
<body>
    <div id="back-to-top">
        <span>▲</span>
        <p>Top</p>
    </div>

    <div id="wrapper">
        <div id="sidebar" class="fl">
            <a href="http://xadillax.github.io">
                <img class="avatar" src="https://secure.gravatar.com/avatar/564d6bd6e577a0e1859a58a0aaf82c5f?s=64" alt="艾克斯の編碼者" />
            </a>
            <p class="italic">艾克斯の編碼者</p>
            <p></p>

            <ul id="primary-nav">
                <li><span class="home"></span><a href="http://xadillax.github.io">首页</a></li>
                <li><span class="portfolio"></span><a href="http://xadillax.github.io/archive.html">存档</a></li>
                <li><span class="contact"></span><a href="http://xadillax.github.io/categories.html">分类</a></li>
                <li><span class="about"></span><a href="http://xadillax.github.io/curriculumvitae.html">关于</a></li>
                <li><span class="mail"></span><a href="http://xadillax.github.io/rss.xml">订阅</a></li>
            </ul>
        </div>

        <div id="container" class="fr">
            <div id="main" class="fl">
                <div class="mini-wrapper">
                    
<div class="gridcol-1">
    <h1 class="pattern">
        <span>
            一起撸Node.JS（壹）——基本语法和类型
        </span>
    </h1>

    <span class="fl">
        <span class="date">16 August 2013</span>
        <span class="tags">
            
            
            
            
            <a href="/tags.html#Node.js-ref">Node.js</a>
            
            <a href="/tags.html#JavaScript-ref">JavaScript</a>
            
            <a href="/tags.html#一起撸Node.JS-ref">一起撸Node.JS</a>
            
            
            
            
        </span>
    </span>

    <div class="cl"></div>

    <article class="rich-content">
        <p>　　<strong>Node.js</strong> 的基础是 <strong>JavaScript</strong> 这门 <strong><em>脚本语言</em></strong>。而大多数的脚本语言一个共同的特点就是“<a href="http://zh.wikipedia.org/wiki/%E9%A1%9E%E5%9E%8B%E7%B3%BB%E7%B5%B1#.E5.BC.B7.E5.9E.8B.E5.88.A5.E5.92.8C.E5.BC.B1.E5.9E.8B.E5.88.A5">弱类型</a>”。</p>
<p>　　不同于 <strong>PHP</strong> 的是，<strong>PHP</strong> 就是是有了新变量也无需申明，而 <strong>JavaScript</strong> 则还是需要 <code>var</code> 来申明一下的。而这个 <code>var</code> 涵盖了 <strong>C++</strong> 中的<code>int</code>、<code>string</code>、<code>char</code>等一切类型的含义，甚至是 <code>function</code>。</p>
<p>　　本篇以及后篇的所有内容都是在 <strong>Linux</strong> 或者 <strong>Cygwin</strong> 下用 <strong>vim</strong> 进行编辑（若不是则请自行转变成你自己的方法），然后在命令行下进行查看结果的。</p>
<!-- 我是小小分割符 -->
<h2 id="基本语法"><a href="#基本语法">1. 基本语法</a></h2>
<h3 id="变量声明"><a href="#变量声明">1.1. 变量声明</a></h3>
<p>在 <strong>C/C++</strong> 中，我们这么声明变量的：</p>
<div class="highlight"><pre><code class="c++"><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{}</span>

<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">b</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">)()</span> <span class="o">=</span> <span class="n">foo</span><span class="p">;</span>  <span class="c1">///&lt; 忘了是不是这么写的了，总之是函数指针</span>
</code></pre></div>


<p>而在 <strong>Node.js</strong> 中则是这样的：</p>
<div class="highlight"><pre><code class="js"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{}</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span>
</code></pre></div>


<p>所以，无论是什么类型的变量，在 <strong>Node.js</strong> 中都是以一个 <code>var</code> 来解决的。</p>
<h3 id="循环语句"><a href="#循环语句">1.2. 循环语句</a></h3>
<h4 id="fori"><a href="#fori">1.2.1. for…i</a></h4>
<p>这个循环语句基本上跟 <strong>C/C++</strong> 一样，都是</p>
<div class="highlight"><pre><code class="c++"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">foo</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div>


<p>而鉴于 <strong>Node.js</strong> 是弱类型，所以只需要：</p>
<div class="highlight"><pre><code class="js"><span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">foo</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div>


<h4 id="forin"><a href="#forin">1.2.2. for…in</a></h4>
<p>这是一种后有型的循环语句，类似于 <strong>PHP</strong> 的 <code>foreach</code>。</p>
<p>比如我们有一个 <strong>JSON对象</strong> 如下：</p>
<div class="highlight"><pre><code class="js"><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;hello&quot;</span>     <span class="o">:</span> <span class="s2">&quot;world&quot;</span><span class="p">,</span>
    <span class="s2">&quot;node&quot;</span>      <span class="o">:</span> <span class="s2">&quot;js&quot;</span><span class="p">,</span>
    <span class="s2">&quot;blahblah&quot;</span>  <span class="o">:</span> <span class="s2">&quot;bar&quot;</span>
<span class="p">};</span>
</code></pre></div>


<p>这个时候我们就可以用 <code>for...in</code> 来循环遍历了：</p>
<div class="highlight"><pre><code class="js"><span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">foo</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="nx">foo</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div>


<p>我们如果在命令行中打入下面的命令：</p>
<div class="highlight"><pre><code class="sh"><span class="nv">$ </span>node foo.js
</code></pre></div>


<p>屏幕上就会显示下面的内容了：</p>
<div class="highlight"><pre><code class="sh">hello: world
node: js
blahblah: bar
</code></pre></div>


<blockquote>
<p><strong>提示</strong>：由上可知，<code>for...in</code> 语句是用来遍历 <strong>JSON对象</strong>、<strong>数组</strong>、<strong>对象</strong>的键名的，而不提供键值的遍历。如果要获取键值，只能通过</p>
</blockquote>
<div class="highlight"><pre><code class="js"><span class="nx">foo</span><span class="p">[</span><span class="o">&lt;</span><span class="err">当前键名</span><span class="o">&gt;</span><span class="p">]</span>
</code></pre></div>


<p>的形式来获取。这个跟 <strong>PHP</strong> 的 <code>foreach</code> 还是有一定区别的。</p>
<h4 id="whiledo-dowhile"><a href="#whiledo-dowhile">1.2.3. while…do, do…while</a></h4>
<p>这个就不多做解释了，跟其它语言没什么大的区别，无非就是如果有变量声明的话，需要用 <code>var</code> 就够了。</p>
<h3 id="运算符"><a href="#运算符">1.3. 运算符</a></h3>
<h4 id="section"><a href="#section">1.3.1. +, -, *, /</a></h4>
<p>这几个运算符也就这样，要注意的是 <code>+</code>。它既可以作用于字符串，也可以作用于数值运算。弱类型语言虽然说类型是弱的，数字有时候可以以字符串的形态出现，字符串有时候可以用数值的形态出现，但是在必要的时候也还是要说一下它是什么类型的，我们可以用下面的代码去看看结果：</p>
<div class="highlight"><pre><code class="js"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">parseInt</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">+</span> <span class="nx">b</span><span class="p">);</span>
</code></pre></div>


<blockquote>
<p>这里的 <code>parseInt</code> 是 <strong>Node.js</strong> 的一个内置函数，作用是将一个字符串解析成 <code>int</code> 类型的变量。</p>
</blockquote>
<p>上面的代码执行结果是</p>
<div class="highlight"><pre><code class="sh">12
3
</code></pre></div>


<p>第一个 <code>console.log</code> 结果是 <code>12</code>，由于 <code>a</code> 是字符串，所以 <code>b</code> 也被系统以字符串的姿态进行加操作，结果就是将两个字符串黏连在一起就变成了 <code>12</code>。而第二个 <code>console.log</code> 结果是 <code>3</code>，是因为我们将第一个 <code>a</code> 转变为了 <code>int</code> 类型，两个 <code>int</code> 型的变量相加即数值相加，结果当然就是 <code>3</code> 了。</p>
<h4 id="section-1"><a href="#section-1">1.3.1.2. ==, ===, !=, !==</a></h4>
<p>这里有一点要解释，当这个逻辑运算符长度为 <code>2</code> 的时候（<code>==</code>, <code>!=</code>），只是判断外在的值是不是一样的，而不会判断类型。如</p>
<div class="highlight"><pre><code class="js"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">==</span> <span class="nx">b</span><span class="p">);</span>
</code></pre></div>


<p>它输出的结果就是 <code>true</code>。但是如果我们在中间判断的时候再加上一个等号，那么就是严格判断了，需要类型和值都一样的时候才会是 <code>true</code>，否则就是 <code>false</code>。也就是说</p>
<div class="highlight"><pre><code class="js"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">===</span> <span class="nx">b</span><span class="p">);</span>
</code></pre></div>


<p>的时候，返回的结果就是 <code>false</code> 了，因为 <code>a</code> 是 <code>int</code> 型的，而 <code>b</code> 则是字符串。</p>
<blockquote>
<p>顺带着就把条件语句讲了吧，其实这里的 <code>if</code> 跟别的语言没什么两样，就是几个逻辑运算符两个等号三个等号的问题。所以就不多做累述了。</p>
</blockquote>
<h4 id="typeof"><a href="#typeof">1.3.1.3. typeof</a></h4>
<p>这里我姑且把它当成是一个运算符而不是函数了。</p>
<p>这个运算符的作用是判断一个变量的类型，会返回一个字符串，即类型名，具体的执行下面的代码就知道了：</p>
<div class="highlight"><pre><code class="js"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{}</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="s1">&#39;嘘~蛋花汤在睡觉。&#39;</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">e</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;a&quot;</span> <span class="o">:</span> <span class="nx">a</span> <span class="p">};</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">];</span>
<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">h</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">a</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">b</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">c</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">d</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">e</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">f</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">g</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">h</span><span class="p">);</span>
</code></pre></div>


<p>这里的执行结果就将会是：</p>
<div class="highlight"><pre><code class="sh">number
string
number
<span class="k">function</span>
object
object
object
undefined
</code></pre></div>


<h3 id="null-undefined-nan"><a href="#null-undefined-nan">1.4. null, undefined, NaN</a></h3>
<p>在 <strong>JavaScript</strong> 中，有三个特殊的值，如标题所示。其中第一个大家可能都比较熟悉吧，<strong>C/C++</strong> 里面也有，不过是大写的，其本质就是一个</p>
<div class="highlight"><pre><code class="c++"><span class="cp">#define NULL 0</span>
</code></pre></div>


<p>而在 <strong>JavaScript</strong> 中，这三个值所代表的意义都不同。</p>
<h4 id="null"><a href="#null">1.4.1. null</a></h4>
<p><code>null</code> 是一种特殊的 <strong>object</strong>，大致的意思就是空。比如说：</p>
<div class="highlight"><pre><code class="js"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</code></pre></div>


<p>大家都能看懂，就不多做解释了。但是跟 <strong>C/C++</strong> 不同的是，这个 <code>null</code> 跟 <code>0</code> 不相等。</p>
<h4 id="undefined"><a href="#undefined">1.4.2. undefined</a></h4>
<p>这个东西的意思就是说这个变量未声明。为了能够更好地区分 <code>null</code>，我们的样例代码如下写：</p>
<div class="highlight"><pre><code class="js"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;foo&quot;</span>       <span class="o">:</span> <span class="kc">null</span>
<span class="p">};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="s2">&quot;foo&quot;</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="s2">&quot;bar&quot;</span><span class="p">]);</span>
</code></pre></div>


<p>上面的代码中，我们让 <code>a[&quot;foo&quot;]</code> 的值为空，即 <code>null</code>。而压根没有声明 <code>a[&quot;bar&quot;]</code> 这个东西，它连空都不是。输出的结果大家都差不多应该猜到了：</p>
<div class="highlight"><pre><code class="sh">null
undefined
</code></pre></div>


<h4 id="nan"><a href="#nan">1.4.3. NaN</a></h4>
<p>这是一个空的数值，是一个特殊的 <code>number</code>。它的全称是 <code>Not a Number</code>。有点奇怪，大家可以理解为 <strong>不是数字形态，或者数值出错的 <code>number</code> 类型变量</strong>。</p>
<p>多在浮点型数值运算错误（如被0除）的情况下出现，甚至可以是用户自己让一个变量等于 <code>NaN</code> 以便返回一个错误值让大家知道这个函数运算出错了云云。</p>
<h3 id="小杂碎"><a href="#小杂碎">1.5. 小杂碎</a></h3>
<p>其它剩余的语句也跟已存在的其它语言差不多，比如说 <code>break</code> 啊、<code>switch</code> 啊、<code>continue</code> 啊等等等等。</p>
<h2 id="变量类型"><a href="#变量类型">2. 变量类型</a></h2>
<p>这一节主要讲的是 <strong>JavaScript</strong> 对象，其它类型差不多一带而过吧。</p>
<h3 id="基础类型"><a href="#基础类型">2.1. 基础类型</a></h3>
<p><strong>Node.js</strong> 包含的基础类型差不多有如下几个：</p>
<ul>
<li>number</li>
<li>string</li>
<li>boolean</li>
<li>array</li>
</ul>
<p>其中前三种类型可以直接赋值，而 <code>array</code> 的赋值只是一个引用赋值而已，在新变量中改变某个值的话旧变量的值也会改变，直接可以试试下面的代码：</p>
<div class="highlight"><pre><code class="js"><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">];</span>
<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span>
<span class="nx">bar</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>
</code></pre></div>


<p>它得出的结果是：</p>
<div class="highlight"><pre><code class="sh"><span class="o">[</span> 3, 2, 3 <span class="o">]</span>
</code></pre></div>


<p>也就是说 <code>array</code> 要是复制出一个新的数组的话，不能用直接赋值的方法，而必须“<strong><a href="#深拷贝">深拷贝</a></strong>”。</p>
<p>这里有必要讲一下 <code>array</code> 的三种创建方法。</p>
<p>第一种：</p>
<div class="highlight"><pre><code class="js"><span class="kd">var</span> <span class="nx">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">();</span>
<span class="nx">dog</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;嘘~&quot;</span><span class="p">;</span>
<span class="nx">dog</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;蛋花汤&quot;</span><span class="p">;</span>
<span class="nx">dog</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;在睡觉&quot;</span><span class="p">;</span>
</code></pre></div>


<p>第二种：</p>
<div class="highlight"><pre><code class="js"><span class="kd">var</span> <span class="nx">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span> <span class="s2">&quot;嘘~&quot;</span><span class="p">,</span> <span class="s2">&quot;蛋花汤&quot;</span><span class="p">,</span> <span class="s2">&quot;在睡觉&quot;</span> <span class="p">);</span>
</code></pre></div>


<p>第四种：</p>
<div class="highlight"><pre><code class="js"><span class="kd">var</span> <span class="nx">dog</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;嘘~&quot;</span><span class="p">,</span>
    <span class="s2">&quot;蛋花汤&quot;</span><span class="p">,</span>
    <span class="s2">&quot;在睡觉&quot;</span>
<span class="p">];</span>
</code></pre></div>


<p>我个人比较喜欢第三种写法，比较简洁。</p>
<h3 id="json对象"><a href="#json对象">2.2. JSON对象</a></h3>
<p>这里我把 <strong>JSON对象</strong> 单独拎出来而不是把它归类为 <strong>JavaScript对象</strong>，如果觉得我有点误人子弟就可以直接跳过这一节了。</p>
<p>本人对于 <strong>JSON对象</strong> 和 <strong>JavaScript</strong> 对象的区分放在 <strong>是否只用来存储数据，而并非是一个类的实例化</strong>。其实 <strong>JSON</strong> 的本质便是 <strong>JavaScript Object Notation</strong>。</p>
<blockquote>
<p>更多有关 <strong><a href="http://zh.wikipedia.org/wiki/JSON">JSON</a></strong> 的信息请自行百科。</p>
</blockquote>
<p>在 <strong>Node.js</strong> 中声明一个 <strong>JSON对象</strong> 非常简单：</p>
<div class="highlight"><pre><code class="js"><span class="kd">var</span> <span class="nx">dog</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;pre&quot;</span>       <span class="o">:</span> <span class="s2">&quot;嘘~&quot;</span><span class="p">,</span>
    <span class="s2">&quot;sub&quot;</span>       <span class="o">:</span> <span class="p">{</span>
        <span class="s2">&quot;name&quot;</span>  <span class="o">:</span> <span class="s2">&quot;蛋花汤&quot;</span><span class="p">,</span>
        <span class="s2">&quot;act&quot;</span>   <span class="o">:</span> <span class="s2">&quot;在睡觉&quot;</span><span class="p">,</span>
        <span class="s2">&quot;time&quot;</span>  <span class="o">:</span> <span class="mi">12</span>
    <span class="p">},</span>

    <span class="s2">&quot;suf&quot;</span>       <span class="o">:</span> <span class="p">[</span> <span class="s2">&quot;我说了&quot;</span><span class="p">,</span> <span class="s2">&quot;它在睡觉&quot;</span><span class="p">,</span> <span class="s2">&quot;就是在睡觉&quot;</span> <span class="p">]</span>
<span class="p">};</span>
</code></pre></div>


<p>有两种方式能得到 <strong>JSON对象</strong> 中的某个键名的键值，第一种是用点连接，第二种是用中括号：</p>
<div class="highlight"><pre><code class="js"><span class="nx">dog</span><span class="p">.</span><span class="nx">pre</span><span class="p">;</span>
<span class="nx">dog</span><span class="p">[</span><span class="s2">&quot;pre&quot;</span><span class="p">];</span>
</code></pre></div>


<blockquote>
<p><strong>试试看</strong>：现在你自己动手试试看，用 <code>for...in</code> 的形式遍历一遍上面的 <code>JSON对象</code>。别忘了用上 <code>typeof</code> 喵~</p>
</blockquote>
<h3 id="类对象的基础"><a href="#类对象的基础">2.3. 类（对象）的基础</a></h3>
<p>严格意义上来讲，<strong>Node.js</strong> 的类不能算是类，其实它只是一个函数的集合体，加一些成员变量。它的本质其实是一个函数。</p>
<p>不过为了通俗地讲，我们接下去以及以后都将其称为“类”，实例化的叫“对象”。</p>
<p>因为类有着很多 <strong>函数</strong> 的特性，或者说它的本质就是一个 <strong>函数</strong>，所以这里面我们可能一不留神就顺带着把函数基础给讲了。</p>
<h4 id="类的声明和实例化"><a href="#类的声明和实例化">2.3.1. 类的声明和实例化</a></h4>
<p>声明一个类非常简单，大家不要笑：</p>
<div class="highlight"><pre><code class="js"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div>


<p>好了，我们已经写好了一个 <code>foo</code> 类了。</p>
<blockquote>
<p>真的假的？！真的。</p>
</blockquote>
<p>不信？不信你可以接下去打一段代码看看：</p>
<div class="highlight"><pre><code class="js"><span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">foo</span><span class="p">();</span>
</code></pre></div>


<p>别看它是一个函数，如果以这样的形式（<code>new</code>）写出来，它就是这个类的实例化。</p>
<p>而这个所谓的 <code>foo()</code> 其实就是这个 <code>foo()</code> 类的构造函数。</p>
<h4 id="成员变量"><a href="#成员变量">2.3.2. 成员变量</a></h4>
<p>成员变量有好两种方法。</p>
<p>第一种就是在类的构造函数或者任何构造函数中使用 <code>this.&lt;变量名&gt;</code> 。你可以在任何时候声明一个成员变量，在外部不影响使用，反正就算在还未声明的时候使用它，也会有一个 <code>undefined</code> 来撑着。所以说这就是第一种方法：</p>
<div class="highlight"><pre><code class="js"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">hello</span> <span class="o">=</span> <span class="s2">&quot;world&quot;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<blockquote>
<p><strong>注意</strong>：只有在加了 <code>this</code> 的时候才是调用类的<strong>成员变量</strong>，否则只是函数内的一个局部变量而已。要分清楚有没有 <code>this</code> 的时候变量的作用范围。</p>
</blockquote>
<p>第二种方法就是在构造函数或者任何成员函数外部声明，其格式是 <code>&lt;类名&gt;.prototype.&lt;变量名&gt;</code>：</p>
<div class="highlight"><pre><code class="js"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//...</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hello</span> <span class="o">=</span> <span class="s2">&quot;world&quot;</span><span class="p">;</span>
</code></pre></div>


<p>无聊上面哪种方法都是对成员变量的声明，我们可以看看效果：</p>
<div class="highlight"><pre><code class="js"><span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">foo</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bar</span><span class="p">.</span><span class="nx">hello</span><span class="p">);</span>
</code></pre></div>


<p>甚至你可以这么修改这个类：</p>
<div class="highlight"><pre><code class="js"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">hello</span> <span class="o">=</span> <span class="s2">&quot;world&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hello</span> <span class="o">=</span> <span class="s2">&quot;蛋花汤&quot;</span><span class="p">;</span>
</code></pre></div>


<p>然后再用上面的代码输出。</p>
<blockquote>
<p>想想看为什么输出的还是 <code>world</code> 而不是 <code>蛋花汤</code>。</p>
</blockquote>
<h4 id="构造函数"><a href="#构造函数">2.3.2. 构造函数</a></h4>
<p>我们之前说过了这个 <code>foo()</code> 实际上是一个 <strong>构造函数</strong>。那么显然我们可以给构造函数传参数，所以就有了下面的代码：</p>
<div class="highlight"><pre><code class="js"><span class="c1">// 代码2.1</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">hello</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">hello</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">hello</span> <span class="o">=</span> <span class="s2">&quot;world&quot;</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">hello</span> <span class="o">=</span> <span class="nx">hello</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


<p>我们看到上面有一个奇葩的判断 <code>if(hello === undefined)</code>，这个判断有什么用呢？第一种可能，就是开发者很蛋疼地特意传进去一个 <code>undefined</code> 进去，这个时候它是 <code>undefined</code> 无可厚非。</p>
<p>还有一种情况。我们一开始就说了 <strong>JavaScript</strong> 是一门弱类型语言，其实不仅仅是弱类型，它的传参数也非常不严谨。你可以多传或者少传（只要保证你多传或者少传的时候可以保证程序不出错，或者逻辑不出错），原则上都是可以的。多传的参数会被自动忽略，而少传的参数会以 <code>undefined</code> 补足。</p>
<p>看看下面的代码就明白了：</p>
<div class="highlight"><pre><code class="js"><span class="c1">// 上接代码2.1</span>
<span class="kd">var</span> <span class="nx">bar1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">foo</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">bar2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">foo</span><span class="p">(</span><span class="s2">&quot;蛋花汤&quot;</span><span class="p">);</span>
</code></pre></div>


<p>请自行输出一下两个 <code>bar</code> 的 <code>hello</code> 变量，会发现一个是 <strong>world</strong> 一个是 <strong>蛋花汤</strong>。显而易见，我们的第一个 <code>bar1</code> 在声明的时候，被 <strong>Node.js</strong> 自动看成了：</p>
<div class="highlight"><pre><code class="js"><span class="kd">var</span> <span class="nx">bar1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">foo</span><span class="p">(</span><span class="kc">undefined</span><span class="p">);</span>
</code></pre></div>


<p>所以就有了它是 <strong>world</strong> 一说。</p>
<p>还有就是在这个构造函数中，我们看到了传进去的参数是 <code>hello</code> 而这个类中本来就有个成员变量就是 <code>this.hello</code>。不过我们之前说过了有 <code>this</code> 和没 <code>this</code> 的时候作用域不同，那个参数只是作用于构造函数中，而加了 <code>this</code> 的那个则是成员变量。用一个 <code>this</code> 就马上区分开来他们了，所以即使同名也没关系。</p>
<h4 id="成员函数"><a href="#成员函数">2.3.3. 成员函数</a></h4>
<h5 id="成员函数声明"><a href="#成员函数声明">2.3.3.1. 成员函数声明</a></h5>
<p>成员函数的声明跟成员变量的第二种声明方法差不多，即 <code>&lt;类名&gt;.prototype.&lt;函数名&gt; = &lt;函数&gt;;</code></p>
<div class="highlight"><pre><code class="js"><span class="c1">// 上接代码2.1</span>
<span class="kd">function</span> <span class="nx">setHello</span><span class="p">(</span><span class="nx">hello</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">hello</span> <span class="o">=</span> <span class="nx">hello</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">setHello</span> <span class="o">=</span> <span class="nx">setHello</span><span class="p">;</span>

<span class="nx">bar1</span><span class="p">.</span><span class="nx">setHello</span><span class="p">(</span><span class="s2">&quot;鸡蛋饼&quot;</span><span class="p">);</span>
</code></pre></div>


<p>上面这段代码显而易见，我们实现了 <code>foo</code> 类的 <code>setHello</code> 函数，能通过它修改 <code>foo.hello</code> 的值。</p>
<p>但是这么写是不是有点麻烦？接下去我要讲一个 <strong>JavaScript</strong> 函数重要的特性了。</p>
<h4 id="匿名函数"><a href="#匿名函数">2.3.3.2. ★ 匿名函数</a></h4>
<p>很多时候我们的某些函数只在一个地方被引用或者调用，那么我们为这个函数起一个名字就太不值了，没必要，所以我们可以临时写好这个函数，直接让引用它的人引用它，调用它的人调用它。所以函数可以省略函数名，如：</p>
<div class="highlight"><pre><code class="js"><span class="kd">function</span><span class="p">(</span><span class="nx">hello</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">hello</span> <span class="o">=</span> <span class="nx">hello</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>至于怎么引用或者调用呢？如果是上面的那个类需要引用的话，就是写成这样的：</p>
<div class="highlight"><pre><code class="js"><span class="nx">foo</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">setHello</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">hello</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">hello</span> <span class="o">=</span> <span class="nx">hello</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>这样的写法跟 <strong><a href="#成员函数声明">2.3.3.1. 成员函数声明</a></strong> 是一个效果的，而且省了很多的代码量。而且实际上，基本上的类成员函数的声明都是采用这种匿名函数的方式来声明的。</p>
<p>至于说怎么样让匿名函数被调用呢？这通常用于传入一个只被某个函数调用的函数时这样写。</p>
<p>比如我们有一个函数的原型是：</p>
<div class="highlight"><pre><code class="js"><span class="cm">/**</span>
<span class="cm"> * 我们将传入a，b两个变量，</span>
<span class="cm"> * 在算出a+b的值后，交由func(num)</span>
<span class="cm"> * 去进行输出</span>
<span class="cm"> */</span>
<span class="kd">function</span> <span class="nx">sumab</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">func</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
    <span class="nx">func</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>


<p>比如我们有两个版本的输出函数，一个是中文输出，一个是英文输出，那么如果不用匿名函数时候是这么写的：</p>
<div class="highlight"><pre><code class="js"><span class="kd">function</span> <span class="nx">zh</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">sum</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="s2">&quot; + &quot;</span> <span class="o">+</span> <span class="nx">b</span> <span class="o">+</span> <span class="s2">&quot; 的值是：&quot;</span> <span class="o">+</span> <span class="nx">sum</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">en</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">sum</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="s2">&quot; plus &quot;</span> <span class="o">+</span> <span class="nx">b</span> <span class="o">+</span> <span class="s2">&quot; is &quot;</span> <span class="o">+</span> <span class="nx">sum</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">sumab</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">zh</span><span class="p">);</span>
<span class="nx">sumab</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nx">en</span><span class="p">);</span>
</code></pre></div>


<p>执行一遍这段代码，输出的结果将会是：</p>
<div class="highlight"><pre><code class="sh">1 + 2 的值是：3
3 plus 4 is 7
</code></pre></div>


<p>这样的代码如果采用匿名函数的形式则将会是：</p>
<div class="highlight"><pre><code class="js"><span class="nx">sumab</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">sum</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="s2">&quot; + &quot;</span> <span class="o">+</span> <span class="nx">b</span> <span class="o">+</span> <span class="s2">&quot; 的值是：&quot;</span> <span class="o">+</span> <span class="nx">sum</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">sumab</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">sum</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="s2">&quot; plus &quot;</span> <span class="o">+</span> <span class="nx">b</span> <span class="o">+</span> <span class="s2">&quot; is &quot;</span> <span class="o">+</span> <span class="nx">sum</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>


<p>这种形式通常使用于回调函数。回调机制算是 <strong>Node.js</strong> 或者说 <strong>JavaScript</strong> 的精髓。在以后的篇章会做介绍。</p>
<h4 id="成员函数声明的匿名函数声明方式"><a href="#成员函数声明的匿名函数声明方式">2.3.3.3. 成员函数声明的匿名函数声明方式</a></h4>
<p>虽然上一节讲过了，不过还是再讲一遍吧。</p>
<p>通常我们声明类的成员函数时候都是用匿名函数来声明的，因为反正那个函数也就是这个类的一个成员函数而已，不会在其它地方被单独引用或者调用，所以就有了下面的代码：</p>
<div class="highlight"><pre><code class="js"><span class="c1">// 上接代码2.1</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">setHello</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">hello</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">hello</span> <span class="o">=</span> <span class="nx">hello</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>这样我们就使得 <code>foo</code> 类有了 <code>setHello</code> 这个函数了。</p>
<h4 id="类的随意性"><a href="#类的随意性">2.3.4. 类的随意性</a></h4>
<p>这个又是我胡扯的。所谓类的随意性即 <strong>JavaScript</strong> 中你可以在任何地方修改你的类，这跟 <strong>Ruby</strong> 有着一定的相似之处。</p>
<p>比如说 <code>string</code> ，它其实也是一个类，有着诸如 <code>length</code> 这样的成员变量，也有 <code>indexOf</code>、<code>substr</code> 等成员函数。但是万一我们觉得这个 <code>string</code> 有些地方不完善，想加自己的方法，那么可以在你想要的地方给它增加一个函数，比如：</p>
<div class="highlight"><pre><code class="js"><span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sb</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">newstr</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">newstr</span> <span class="o">+=</span> <span class="s2">&quot;s&quot;</span><span class="p">;</span>
        <span class="k">else</span> <span class="nx">newstr</span> <span class="o">+=</span> <span class="s2">&quot;b&quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">newstr</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>


<p>这个函数的意思就是填充一个字符串，使其变成 <code>sb</code> 的化身。</p>
<p>我们来测试一下：</p>
<div class="highlight"><pre><code class="js"><span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="s2">&quot;嘘~蛋花汤在睡觉。&quot;</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">str</span><span class="p">.</span><span class="nx">sb</span><span class="p">());</span>
</code></pre></div>


<p>你将会得到这样的结果：</p>
<div class="highlight"><pre><code class="sh">sbsbsbsbs
</code></pre></div>


<blockquote>
<p>你跟你的电脑说“嘘~蛋花汤在睡觉。”，你的电脑会骂你四次半傻逼。（赶快砸了它）</p>
</blockquote>
<h2 id="附"><a href="#附">3. 附</a></h2>
<h3 id="深拷贝"><a href="#深拷贝">3.1. 深拷贝</a></h3>
<p>所谓深拷贝就是自己新建一个数组或者对象，把源数组或者对象中的基础类型变量值一个个手动拷过去，而不是只把源数组或者对象的引用拿过来。所以这就涉及到了一个递归的调用什么的。</p>
<p>下面是我实现的一个深拷贝函数，大家可以写一个自己的然后加入到自己的 <strong>Node.js</strong> 知识库中。</p>
<div class="highlight"><pre><code class="js"><span class="kd">function</span> <span class="nx">cloneObject</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">dest</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">src</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">src</span> <span class="o">===</span> <span class="s2">&quot;object&quot;</span><span class="p">)</span> <span class="nx">dest</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">cloneObject</span><span class="p">(</span><span class="nx">src</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span>
        <span class="k">else</span> <span class="nx">dest</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">src</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">dest</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<h3 id="系统默认对象参考手册"><a href="#系统默认对象参考手册">3.2. 系统默认对象参考手册</a></h3>
<ul>
<li><strong>字符串</strong>：<a href="http://www.w3school.com.cn/js/jsref_obj_string.asp">http://www.w3school.com.cn/js/jsref_obj_string.asp</a></li>
<li><strong>数字</strong>: <a href="http://www.w3school.com.cn/js/jsref_obj_number.asp">http://www.w3school.com.cn/js/jsref_obj_number.asp</a></li>
<li><strong>数组</strong>: <a href="http://www.w3school.com.cn/js/jsref_obj_array.asp">http://www.w3school.com.cn/js/jsref_obj_array.asp</a></li>
<li><strong>布尔</strong>: <a href="http://www.w3school.com.cn/js/jsref_obj_boolean.asp">http://www.w3school.com.cn/js/jsref_obj_boolean.asp</a></li>
<li><strong>日期</strong>: <a href="http://www.w3school.com.cn/js/jsref_obj_date.asp">http://www.w3school.com.cn/js/jsref_obj_date.asp</a></li>
<li><strong>数学库</strong>：<a href="http://www.w3school.com.cn/js/jsref_obj_math.asp">http://www.w3school.com.cn/js/jsref_obj_math.asp</a></li>
</ul>

    </article>
</div>

<div class="gridcol-1">
    
    <span class="fl"><a class="pagination" href="/node-learning/2013/08/15/node-2-environment-in-windows" title="一起撸Node.JS（负贰）——环境">上一篇</a></span>
    

    

    <div class="cl"></div>
</div>

<div class="gridcol-1">
    


  <!-- Duoshuo Comment BEGIN -->
<div class="ds-thread" data-thread-key="/node-learning/2013/08/16/node-3-base" data-title="一起撸Node.JS（壹）——基本语法和类型"></div>
<script type="text/javascript">
var duoshuoQuery = {short_name:"xadillax"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
    || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!-- Duoshuo Comment END -->




</div>


                </div>
            </div>

            <div id="footer" class="fl">
                <div class="mini-wrapper">
                    <div class="gridcol-1-2">
                        <h5 class="pattern"><span>关注我</span></h5>
                        <ul>
                            <li><a href="http://xadillax.github.io/rss.xml">RSS</a></li>
                            <li><a href="https://github.com/XadillaX">GitHub</a></li>
                        </ul>
                    </div>

                    <div class="gridcol-1-2">
                        <h5 class="pattern"><span>版权</span></h5>
                        <p>© 2013 艾克斯の編碼者.</p>
                        <p>Powered by <a href="http://jekyllrb.com">Jekyll</a></p>
                    </div>
                </div>
            </div>

            <div class="cl"></div>
        </div>

        <div class="cl"></div>
    </div>
</body>
</html>
