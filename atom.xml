<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>艾克斯の編碼者</title>
 <link href="http://xadillax.github.io/" rel="self"/>
 <link href="http://xadillax.github.io"/>
 <updated>2013-08-16T16:07:00+08:00</updated>
 <id>http://xadillax.github.io</id>
 <author>
   <name>XadillaX</name>
   <email>admin@xcoder.in</email>
 </author>

 
 <entry>
   <title>一起撸Node.JS（壹）——基本语法和类型</title>
   <link href="http://xadillax.github.io/node-learning/2013/08/16/node-3-base"/>
   <updated>2013-08-16T00:00:00+08:00</updated>
   <id>http://xadillax.github.io/node-learning/2013/08/16/node-3-base</id>
   <content type="html">&lt;p&gt;　　&lt;strong&gt;Node.js&lt;/strong&gt; 的基础是 &lt;strong&gt;JavaScript&lt;/strong&gt; 这门 &lt;strong&gt;&lt;em&gt;脚本语言&lt;/em&gt;&lt;/strong&gt;。而大多数的脚本语言一个共同的特点就是“&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E9%A1%9E%E5%9E%8B%E7%B3%BB%E7%B5%B1#.E5.BC.B7.E5.9E.8B.E5.88.A5.E5.92.8C.E5.BC.B1.E5.9E.8B.E5.88.A5&quot;&gt;弱类型&lt;/a&gt;”。&lt;/p&gt;
&lt;p&gt;　　不同于 &lt;strong&gt;PHP&lt;/strong&gt; 的是，&lt;strong&gt;PHP&lt;/strong&gt; 就是是有了新变量也无需申明，而 &lt;strong&gt;JavaScript&lt;/strong&gt; 则还是需要 &lt;code&gt;var&lt;/code&gt; 来申明一下的。而这个 &lt;code&gt;var&lt;/code&gt; 涵盖了 &lt;strong&gt;C++&lt;/strong&gt; 中的&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;string&lt;/code&gt;、&lt;code&gt;char&lt;/code&gt;等一切类型的含义，甚至是 &lt;code&gt;function&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　本篇以及后篇的所有内容都是在 &lt;strong&gt;Linux&lt;/strong&gt; 或者 &lt;strong&gt;Cygwin&lt;/strong&gt; 下用 &lt;strong&gt;vim&lt;/strong&gt; 进行编辑（若不是则请自行转变成你自己的方法），然后在命令行下进行查看结果的。&lt;/p&gt;
&lt;!-- 我是小小分割符 --&gt;
&lt;h2 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot;&gt;1. 基本语法&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;变量声明&quot;&gt;&lt;a href=&quot;#变量声明&quot;&gt;1.1. 变量声明&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在 &lt;strong&gt;C/C++&lt;/strong&gt; 中，我们这么声明变量的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;///&amp;lt; 忘了是不是这么写的了，总之是函数指针&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而在 &lt;strong&gt;Node.js&lt;/strong&gt; 中则是这样的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;所以，无论是什么类型的变量，在 &lt;strong&gt;Node.js&lt;/strong&gt; 中都是以一个 &lt;code&gt;var&lt;/code&gt; 来解决的。&lt;/p&gt;
&lt;h3 id=&quot;循环语句&quot;&gt;&lt;a href=&quot;#循环语句&quot;&gt;1.2. 循环语句&lt;/a&gt;&lt;/h3&gt;
&lt;h4 id=&quot;fori&quot;&gt;&lt;a href=&quot;#fori&quot;&gt;1.2.1. for…i&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这个循环语句基本上跟 &lt;strong&gt;C/C++&lt;/strong&gt; 一样，都是&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而鉴于 &lt;strong&gt;Node.js&lt;/strong&gt; 是弱类型，所以只需要：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h4 id=&quot;forin&quot;&gt;&lt;a href=&quot;#forin&quot;&gt;1.2.2. for…in&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这是一种后有型的循环语句，类似于 &lt;strong&gt;PHP&lt;/strong&gt; 的 &lt;code&gt;foreach&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;比如我们有一个 &lt;strong&gt;JSON对象&lt;/strong&gt; 如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;world&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;node&amp;quot;&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;js&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;blahblah&amp;quot;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个时候我们就可以用 &lt;code&gt;for...in&lt;/code&gt; 来循环遍历了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;: &amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们如果在命令行中打入下面的命令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;node foo.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;屏幕上就会显示下面的内容了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;hello: world
node: js
blahblah: bar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;：由上可知，&lt;code&gt;for...in&lt;/code&gt; 语句是用来遍历 &lt;strong&gt;JSON对象&lt;/strong&gt;、&lt;strong&gt;数组&lt;/strong&gt;、&lt;strong&gt;对象&lt;/strong&gt;的键名的，而不提供键值的遍历。如果要获取键值，只能通过&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;当前键名&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;的形式来获取。这个跟 &lt;strong&gt;PHP&lt;/strong&gt; 的 &lt;code&gt;foreach&lt;/code&gt; 还是有一定区别的。&lt;/p&gt;
&lt;h4 id=&quot;whiledo-dowhile&quot;&gt;&lt;a href=&quot;#whiledo-dowhile&quot;&gt;1.2.3. while…do, do…while&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这个就不多做解释了，跟其它语言没什么大的区别，无非就是如果有变量声明的话，需要用 &lt;code&gt;var&lt;/code&gt; 就够了。&lt;/p&gt;
&lt;h3 id=&quot;运算符&quot;&gt;&lt;a href=&quot;#运算符&quot;&gt;1.3. 运算符&lt;/a&gt;&lt;/h3&gt;
&lt;h4 id=&quot;section&quot;&gt;&lt;a href=&quot;#section&quot;&gt;1.3.1. +, -, *, /&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这几个运算符也就这样，要注意的是 &lt;code&gt;+&lt;/code&gt;。它既可以作用于字符串，也可以作用于数值运算。弱类型语言虽然说类型是弱的，数字有时候可以以字符串的形态出现，字符串有时候可以用数值的形态出现，但是在必要的时候也还是要说一下它是什么类型的，我们可以用下面的代码去看看结果：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;这里的 &lt;code&gt;parseInt&lt;/code&gt; 是 &lt;strong&gt;Node.js&lt;/strong&gt; 的一个内置函数，作用是将一个字符串解析成 &lt;code&gt;int&lt;/code&gt; 类型的变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的代码执行结果是&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;12
3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第一个 &lt;code&gt;console.log&lt;/code&gt; 结果是 &lt;code&gt;12&lt;/code&gt;，由于 &lt;code&gt;a&lt;/code&gt; 是字符串，所以 &lt;code&gt;b&lt;/code&gt; 也被系统以字符串的姿态进行加操作，结果就是将两个字符串黏连在一起就变成了 &lt;code&gt;12&lt;/code&gt;。而第二个 &lt;code&gt;console.log&lt;/code&gt; 结果是 &lt;code&gt;3&lt;/code&gt;，是因为我们将第一个 &lt;code&gt;a&lt;/code&gt; 转变为了 &lt;code&gt;int&lt;/code&gt; 类型，两个 &lt;code&gt;int&lt;/code&gt; 型的变量相加即数值相加，结果当然就是 &lt;code&gt;3&lt;/code&gt; 了。&lt;/p&gt;
&lt;h4 id=&quot;section-1&quot;&gt;&lt;a href=&quot;#section-1&quot;&gt;1.3.1.2. ==, ===, !=, !==&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这里有一点要解释，当这个逻辑运算符长度为 &lt;code&gt;2&lt;/code&gt; 的时候（&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;），只是判断外在的值是不是一样的，而不会判断类型。如&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;它输出的结果就是 &lt;code&gt;true&lt;/code&gt;。但是如果我们在中间判断的时候再加上一个等号，那么就是严格判断了，需要类型和值都一样的时候才会是 &lt;code&gt;true&lt;/code&gt;，否则就是 &lt;code&gt;false&lt;/code&gt;。也就是说&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;的时候，返回的结果就是 &lt;code&gt;false&lt;/code&gt; 了，因为 &lt;code&gt;a&lt;/code&gt; 是 &lt;code&gt;int&lt;/code&gt; 型的，而 &lt;code&gt;b&lt;/code&gt; 则是字符串。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;顺带着就把条件语句讲了吧，其实这里的 &lt;code&gt;if&lt;/code&gt; 跟别的语言没什么两样，就是几个逻辑运算符两个等号三个等号的问题。所以就不多做累述了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;typeof&quot;&gt;&lt;a href=&quot;#typeof&quot;&gt;1.3.1.3. typeof&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这里我姑且把它当成是一个运算符而不是函数了。&lt;/p&gt;
&lt;p&gt;这个运算符的作用是判断一个变量的类型，会返回一个字符串，即类型名，具体的执行下面的代码就知道了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;嘘~蛋花汤在睡觉。&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里的执行结果就将会是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;number
string
number
&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt;
object
object
object
undefined
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id=&quot;null-undefined-nan&quot;&gt;&lt;a href=&quot;#null-undefined-nan&quot;&gt;1.4. null, undefined, NaN&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在 &lt;strong&gt;JavaScript&lt;/strong&gt; 中，有三个特殊的值，如标题所示。其中第一个大家可能都比较熟悉吧，&lt;strong&gt;C/C++&lt;/strong&gt; 里面也有，不过是大写的，其本质就是一个&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#define NULL 0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而在 &lt;strong&gt;JavaScript&lt;/strong&gt; 中，这三个值所代表的意义都不同。&lt;/p&gt;
&lt;h4 id=&quot;null&quot;&gt;&lt;a href=&quot;#null&quot;&gt;1.4.1. null&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;null&lt;/code&gt; 是一种特殊的 &lt;strong&gt;object&lt;/strong&gt;，大致的意思就是空。比如说：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;大家都能看懂，就不多做解释了。但是跟 &lt;strong&gt;C/C++&lt;/strong&gt; 不同的是，这个 &lt;code&gt;null&lt;/code&gt; 跟 &lt;code&gt;0&lt;/code&gt; 不相等。&lt;/p&gt;
&lt;h4 id=&quot;undefined&quot;&gt;&lt;a href=&quot;#undefined&quot;&gt;1.4.2. undefined&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这个东西的意思就是说这个变量未声明。为了能够更好地区分 &lt;code&gt;null&lt;/code&gt;，我们的样例代码如下写：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的代码中，我们让 &lt;code&gt;a[&amp;quot;foo&amp;quot;]&lt;/code&gt; 的值为空，即 &lt;code&gt;null&lt;/code&gt;。而压根没有声明 &lt;code&gt;a[&amp;quot;bar&amp;quot;]&lt;/code&gt; 这个东西，它连空都不是。输出的结果大家都差不多应该猜到了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;null
undefined
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h4 id=&quot;nan&quot;&gt;&lt;a href=&quot;#nan&quot;&gt;1.4.3. NaN&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这是一个空的数值，是一个特殊的 &lt;code&gt;number&lt;/code&gt;。它的全称是 &lt;code&gt;Not a Number&lt;/code&gt;。有点奇怪，大家可以理解为 &lt;strong&gt;不是数字形态，或者数值出错的 &lt;code&gt;number&lt;/code&gt; 类型变量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;多在浮点型数值运算错误（如被0除）的情况下出现，甚至可以是用户自己让一个变量等于 &lt;code&gt;NaN&lt;/code&gt; 以便返回一个错误值让大家知道这个函数运算出错了云云。&lt;/p&gt;
&lt;h3 id=&quot;小杂碎&quot;&gt;&lt;a href=&quot;#小杂碎&quot;&gt;1.5. 小杂碎&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;其它剩余的语句也跟已存在的其它语言差不多，比如说 &lt;code&gt;break&lt;/code&gt; 啊、&lt;code&gt;switch&lt;/code&gt; 啊、&lt;code&gt;continue&lt;/code&gt; 啊等等等等。&lt;/p&gt;
&lt;h2 id=&quot;变量类型&quot;&gt;&lt;a href=&quot;#变量类型&quot;&gt;2. 变量类型&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这一节主要讲的是 &lt;strong&gt;JavaScript&lt;/strong&gt; 对象，其它类型差不多一带而过吧。&lt;/p&gt;
&lt;h3 id=&quot;基础类型&quot;&gt;&lt;a href=&quot;#基础类型&quot;&gt;2.1. 基础类型&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Node.js&lt;/strong&gt; 包含的基础类型差不多有如下几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;number&lt;/li&gt;
&lt;li&gt;string&lt;/li&gt;
&lt;li&gt;boolean&lt;/li&gt;
&lt;li&gt;array&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中前三种类型可以直接赋值，而 &lt;code&gt;array&lt;/code&gt; 的赋值只是一个引用赋值而已，在新变量中改变某个值的话旧变量的值也会改变，直接可以试试下面的代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;它得出的结果是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; 3, 2, 3 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也就是说 &lt;code&gt;array&lt;/code&gt; 要是复制出一个新的数组的话，不能用直接赋值的方法，而必须“&lt;strong&gt;&lt;a href=&quot;#深拷贝&quot;&gt;深拷贝&lt;/a&gt;&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;这里有必要讲一下 &lt;code&gt;array&lt;/code&gt; 的三种创建方法。&lt;/p&gt;
&lt;p&gt;第一种：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dog&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;嘘~&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;蛋花汤&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;在睡觉&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二种：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dog&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;嘘~&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;蛋花汤&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;在睡觉&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第四种：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dog&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;嘘~&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;蛋花汤&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;在睡觉&amp;quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我个人比较喜欢第三种写法，比较简洁。&lt;/p&gt;
&lt;h3 id=&quot;json对象&quot;&gt;&lt;a href=&quot;#json对象&quot;&gt;2.2. JSON对象&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这里我把 &lt;strong&gt;JSON对象&lt;/strong&gt; 单独拎出来而不是把它归类为 &lt;strong&gt;JavaScript对象&lt;/strong&gt;，如果觉得我有点误人子弟就可以直接跳过这一节了。&lt;/p&gt;
&lt;p&gt;本人对于 &lt;strong&gt;JSON对象&lt;/strong&gt; 和 &lt;strong&gt;JavaScript&lt;/strong&gt; 对象的区分放在 &lt;strong&gt;是否只用来存储数据，而并非是一个类的实例化&lt;/strong&gt;。其实 &lt;strong&gt;JSON&lt;/strong&gt; 的本质便是 &lt;strong&gt;JavaScript Object Notation&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;更多有关 &lt;strong&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/JSON&quot;&gt;JSON&lt;/a&gt;&lt;/strong&gt; 的信息请自行百科。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 &lt;strong&gt;Node.js&lt;/strong&gt; 中声明一个 &lt;strong&gt;JSON对象&lt;/strong&gt; 非常简单：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dog&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;pre&amp;quot;&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;嘘~&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;sub&amp;quot;&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;s2&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;蛋花汤&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s2&quot;&gt;&amp;quot;act&amp;quot;&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;在睡觉&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s2&quot;&gt;&amp;quot;time&amp;quot;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;

    &lt;span class=&quot;s2&quot;&gt;&amp;quot;suf&amp;quot;&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;我说了&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;它在睡觉&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;就是在睡觉&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有两种方式能得到 &lt;strong&gt;JSON对象&lt;/strong&gt; 中的某个键名的键值，第一种是用点连接，第二种是用中括号：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;pre&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;试试看&lt;/strong&gt;：现在你自己动手试试看，用 &lt;code&gt;for...in&lt;/code&gt; 的形式遍历一遍上面的 &lt;code&gt;JSON对象&lt;/code&gt;。别忘了用上 &lt;code&gt;typeof&lt;/code&gt; 喵~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;类对象的基础&quot;&gt;&lt;a href=&quot;#类对象的基础&quot;&gt;2.3. 类（对象）的基础&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;严格意义上来讲，&lt;strong&gt;Node.js&lt;/strong&gt; 的类不能算是类，其实它只是一个函数的集合体，加一些成员变量。它的本质其实是一个函数。&lt;/p&gt;
&lt;p&gt;不过为了通俗地讲，我们接下去以及以后都将其称为“类”，实例化的叫“对象”。&lt;/p&gt;
&lt;p&gt;因为类有着很多 &lt;strong&gt;函数&lt;/strong&gt; 的特性，或者说它的本质就是一个 &lt;strong&gt;函数&lt;/strong&gt;，所以这里面我们可能一不留神就顺带着把函数基础给讲了。&lt;/p&gt;
&lt;h4 id=&quot;类的声明和实例化&quot;&gt;&lt;a href=&quot;#类的声明和实例化&quot;&gt;2.3.1. 类的声明和实例化&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;声明一个类非常简单，大家不要笑：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;好了，我们已经写好了一个 &lt;code&gt;foo&lt;/code&gt; 类了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;真的假的？！真的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不信？不信你可以接下去打一段代码看看：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;别看它是一个函数，如果以这样的形式（&lt;code&gt;new&lt;/code&gt;）写出来，它就是这个类的实例化。&lt;/p&gt;
&lt;p&gt;而这个所谓的 &lt;code&gt;foo()&lt;/code&gt; 其实就是这个 &lt;code&gt;foo()&lt;/code&gt; 类的构造函数。&lt;/p&gt;
&lt;h4 id=&quot;成员变量&quot;&gt;&lt;a href=&quot;#成员变量&quot;&gt;2.3.2. 成员变量&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;成员变量有好两种方法。&lt;/p&gt;
&lt;p&gt;第一种就是在类的构造函数或者任何构造函数中使用 &lt;code&gt;this.&amp;lt;变量名&amp;gt;&lt;/code&gt; 。你可以在任何时候声明一个成员变量，在外部不影响使用，反正就算在还未声明的时候使用它，也会有一个 &lt;code&gt;undefined&lt;/code&gt; 来撑着。所以说这就是第一种方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;world&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：只有在加了 &lt;code&gt;this&lt;/code&gt; 的时候才是调用类的&lt;strong&gt;成员变量&lt;/strong&gt;，否则只是函数内的一个局部变量而已。要分清楚有没有 &lt;code&gt;this&lt;/code&gt; 的时候变量的作用范围。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第二种方法就是在构造函数或者任何成员函数外部声明，其格式是 &lt;code&gt;&amp;lt;类名&amp;gt;.prototype.&amp;lt;变量名&amp;gt;&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;world&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;无聊上面哪种方法都是对成员变量的声明，我们可以看看效果：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;甚至你可以这么修改这个类：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;world&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;蛋花汤&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后再用上面的代码输出。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;想想看为什么输出的还是 &lt;code&gt;world&lt;/code&gt; 而不是 &lt;code&gt;蛋花汤&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot;&gt;2.3.2. 构造函数&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;我们之前说过了这个 &lt;code&gt;foo()&lt;/code&gt; 实际上是一个 &lt;strong&gt;构造函数&lt;/strong&gt;。那么显然我们可以给构造函数传参数，所以就有了下面的代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 代码2.1&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;world&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们看到上面有一个奇葩的判断 &lt;code&gt;if(hello === undefined)&lt;/code&gt;，这个判断有什么用呢？第一种可能，就是开发者很蛋疼地特意传进去一个 &lt;code&gt;undefined&lt;/code&gt; 进去，这个时候它是 &lt;code&gt;undefined&lt;/code&gt; 无可厚非。&lt;/p&gt;
&lt;p&gt;还有一种情况。我们一开始就说了 &lt;strong&gt;JavaScript&lt;/strong&gt; 是一门弱类型语言，其实不仅仅是弱类型，它的传参数也非常不严谨。你可以多传或者少传（只要保证你多传或者少传的时候可以保证程序不出错，或者逻辑不出错），原则上都是可以的。多传的参数会被自动忽略，而少传的参数会以 &lt;code&gt;undefined&lt;/code&gt; 补足。&lt;/p&gt;
&lt;p&gt;看看下面的代码就明白了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 上接代码2.1&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;蛋花汤&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;请自行输出一下两个 &lt;code&gt;bar&lt;/code&gt; 的 &lt;code&gt;hello&lt;/code&gt; 变量，会发现一个是 &lt;strong&gt;world&lt;/strong&gt; 一个是 &lt;strong&gt;蛋花汤&lt;/strong&gt;。显而易见，我们的第一个 &lt;code&gt;bar1&lt;/code&gt; 在声明的时候，被 &lt;strong&gt;Node.js&lt;/strong&gt; 自动看成了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;所以就有了它是 &lt;strong&gt;world&lt;/strong&gt; 一说。&lt;/p&gt;
&lt;p&gt;还有就是在这个构造函数中，我们看到了传进去的参数是 &lt;code&gt;hello&lt;/code&gt; 而这个类中本来就有个成员变量就是 &lt;code&gt;this.hello&lt;/code&gt;。不过我们之前说过了有 &lt;code&gt;this&lt;/code&gt; 和没 &lt;code&gt;this&lt;/code&gt; 的时候作用域不同，那个参数只是作用于构造函数中，而加了 &lt;code&gt;this&lt;/code&gt; 的那个则是成员变量。用一个 &lt;code&gt;this&lt;/code&gt; 就马上区分开来他们了，所以即使同名也没关系。&lt;/p&gt;
&lt;h4 id=&quot;成员函数&quot;&gt;&lt;a href=&quot;#成员函数&quot;&gt;2.3.3. 成员函数&lt;/a&gt;&lt;/h4&gt;
&lt;h5 id=&quot;成员函数声明&quot;&gt;&lt;a href=&quot;#成员函数声明&quot;&gt;2.3.3.1. 成员函数声明&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;成员函数的声明跟成员变量的第二种声明方法差不多，即 &lt;code&gt;&amp;lt;类名&amp;gt;.prototype.&amp;lt;函数名&amp;gt; = &amp;lt;函数&amp;gt;;&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 上接代码2.1&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setHello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setHello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setHello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;bar1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setHello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;鸡蛋饼&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面这段代码显而易见，我们实现了 &lt;code&gt;foo&lt;/code&gt; 类的 &lt;code&gt;setHello&lt;/code&gt; 函数，能通过它修改 &lt;code&gt;foo.hello&lt;/code&gt; 的值。&lt;/p&gt;
&lt;p&gt;但是这么写是不是有点麻烦？接下去我要讲一个 &lt;strong&gt;JavaScript&lt;/strong&gt; 函数重要的特性了。&lt;/p&gt;
&lt;h4 id=&quot;匿名函数&quot;&gt;&lt;a href=&quot;#匿名函数&quot;&gt;2.3.3.2. ★ 匿名函数&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;很多时候我们的某些函数只在一个地方被引用或者调用，那么我们为这个函数起一个名字就太不值了，没必要，所以我们可以临时写好这个函数，直接让引用它的人引用它，调用它的人调用它。所以函数可以省略函数名，如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;至于怎么引用或者调用呢？如果是上面的那个类需要引用的话，就是写成这样的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setHello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样的写法跟 &lt;strong&gt;&lt;a href=&quot;#成员函数声明&quot;&gt;2.3.3.1. 成员函数声明&lt;/a&gt;&lt;/strong&gt; 是一个效果的，而且省了很多的代码量。而且实际上，基本上的类成员函数的声明都是采用这种匿名函数的方式来声明的。&lt;/p&gt;
&lt;p&gt;至于说怎么样让匿名函数被调用呢？这通常用于传入一个只被某个函数调用的函数时这样写。&lt;/p&gt;
&lt;p&gt;比如我们有一个函数的原型是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt; * 我们将传入a，b两个变量，&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt; * 在算出a+b的值后，交由func(num)&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt; * 去进行输出&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sumab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;比如我们有两个版本的输出函数，一个是中文输出，一个是英文输出，那么如果不用匿名函数时候是这么写的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;zh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot; + &amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot; 的值是：&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;en&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot; plus &amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot; is &amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;sumab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;zh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;sumab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;en&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;执行一遍这段代码，输出的结果将会是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;1 + 2 的值是：3
3 plus 4 is 7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样的代码如果采用匿名函数的形式则将会是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;sumab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot; + &amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot; 的值是：&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;sumab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot; plus &amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot; is &amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这种形式通常使用于回调函数。回调机制算是 &lt;strong&gt;Node.js&lt;/strong&gt; 或者说 &lt;strong&gt;JavaScript&lt;/strong&gt; 的精髓。在以后的篇章会做介绍。&lt;/p&gt;
&lt;h4 id=&quot;成员函数声明的匿名函数声明方式&quot;&gt;&lt;a href=&quot;#成员函数声明的匿名函数声明方式&quot;&gt;2.3.3.3. 成员函数声明的匿名函数声明方式&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;虽然上一节讲过了，不过还是再讲一遍吧。&lt;/p&gt;
&lt;p&gt;通常我们声明类的成员函数时候都是用匿名函数来声明的，因为反正那个函数也就是这个类的一个成员函数而已，不会在其它地方被单独引用或者调用，所以就有了下面的代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 上接代码2.1&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setHello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样我们就使得 &lt;code&gt;foo&lt;/code&gt; 类有了 &lt;code&gt;setHello&lt;/code&gt; 这个函数了。&lt;/p&gt;
&lt;h4 id=&quot;类的随意性&quot;&gt;&lt;a href=&quot;#类的随意性&quot;&gt;2.3.4. 类的随意性&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这个又是我胡扯的。所谓类的随意性即 &lt;strong&gt;JavaScript&lt;/strong&gt; 中你可以在任何地方修改你的类，这跟 &lt;strong&gt;Ruby&lt;/strong&gt; 有着一定的相似之处。&lt;/p&gt;
&lt;p&gt;比如说 &lt;code&gt;string&lt;/code&gt; ，它其实也是一个类，有着诸如 &lt;code&gt;length&lt;/code&gt; 这样的成员变量，也有 &lt;code&gt;indexOf&lt;/code&gt;、&lt;code&gt;substr&lt;/code&gt; 等成员函数。但是万一我们觉得这个 &lt;code&gt;string&lt;/code&gt; 有些地方不完善，想加自己的方法，那么可以在你想要的地方给它增加一个函数，比如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;newstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;newstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;s&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;newstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;b&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;newstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个函数的意思就是填充一个字符串，使其变成 &lt;code&gt;sb&lt;/code&gt; 的化身。&lt;/p&gt;
&lt;p&gt;我们来测试一下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;嘘~蛋花汤在睡觉。&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你将会得到这样的结果：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;sbsbsbsbs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;你跟你的电脑说“嘘~蛋花汤在睡觉。”，你的电脑会骂你四次半傻逼。（赶快砸了它）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;附&quot;&gt;&lt;a href=&quot;#附&quot;&gt;3. 附&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;深拷贝&quot;&gt;&lt;a href=&quot;#深拷贝&quot;&gt;3.1. 深拷贝&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;所谓深拷贝就是自己新建一个数组或者对象，把源数组或者对象中的基础类型变量值一个个手动拷过去，而不是只把源数组或者对象的引用拿过来。所以这就涉及到了一个递归的调用什么的。&lt;/p&gt;
&lt;p&gt;下面是我实现的一个深拷贝函数，大家可以写一个自己的然后加入到自己的 &lt;strong&gt;Node.js&lt;/strong&gt; 知识库中。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cloneObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;object&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cloneObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id=&quot;系统默认对象参考手册&quot;&gt;&lt;a href=&quot;#系统默认对象参考手册&quot;&gt;3.2. 系统默认对象参考手册&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;字符串&lt;/strong&gt;：&lt;a href=&quot;http://www.w3school.com.cn/js/jsref_obj_string.asp&quot;&gt;http://www.w3school.com.cn/js/jsref_obj_string.asp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数字&lt;/strong&gt;: &lt;a href=&quot;http://www.w3school.com.cn/js/jsref_obj_number.asp&quot;&gt;http://www.w3school.com.cn/js/jsref_obj_number.asp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数组&lt;/strong&gt;: &lt;a href=&quot;http://www.w3school.com.cn/js/jsref_obj_array.asp&quot;&gt;http://www.w3school.com.cn/js/jsref_obj_array.asp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;布尔&lt;/strong&gt;: &lt;a href=&quot;http://www.w3school.com.cn/js/jsref_obj_boolean.asp&quot;&gt;http://www.w3school.com.cn/js/jsref_obj_boolean.asp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;日期&lt;/strong&gt;: &lt;a href=&quot;http://www.w3school.com.cn/js/jsref_obj_date.asp&quot;&gt;http://www.w3school.com.cn/js/jsref_obj_date.asp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数学库&lt;/strong&gt;：&lt;a href=&quot;http://www.w3school.com.cn/js/jsref_obj_math.asp&quot;&gt;http://www.w3school.com.cn/js/jsref_obj_math.asp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>一起撸Node.JS（负贰）——环境</title>
   <link href="http://xadillax.github.io/node-learning/2013/08/15/node-2-environment-in-windows"/>
   <updated>2013-08-15T00:00:00+08:00</updated>
   <id>http://xadillax.github.io/node-learning/2013/08/15/node-2-environment-in-windows</id>
   <content type="html">&lt;p&gt;　　由于&lt;a href=&quot;/node-learning/2013/08/15/node-2-environment-in-windows#linux-环境&quot;&gt;Linux&lt;/a&gt;中的环境搭建比较简单，所以草草略过。&lt;/p&gt;
&lt;p&gt;　　其实&lt;a href=&quot;/node-learning/2013/08/15/node-2-environment-in-windows#windows-环境&quot;&gt;Windows&lt;/a&gt;下也不算麻烦，但是这里会讲一定量的别的环境的搭建。&lt;/p&gt;
&lt;!-- 我是小小分割符 --&gt;
&lt;h2 id=&quot;linux-环境&quot;&gt;&lt;a href=&quot;#linux-环境&quot;&gt;1. Linux 环境&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;讲到这个就很简单了，跟着下面的 &lt;strong&gt;bash&lt;/strong&gt; 操作即可：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /usr/local/bin
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;wget http://nodejs.org/dist/v0.00.00/node-v0.00.00-linux-x00.tar.gz
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;tar zxf node-v0.00.00-linux-x00.tar.gz
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;node-v0.00.00-linux-x00
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;其中将上方的 &lt;strong&gt;v0.00.00&lt;/strong&gt; 替换成 &lt;strong&gt;Node.js&lt;/strong&gt; 最新的版本号，把 &lt;strong&gt;x00&lt;/strong&gt; 替换成你自己电脑的位数。&lt;/p&gt;
&lt;p&gt;也可以直接去官网 &lt;a href=&quot;http://nodejs.org/download/&quot;&gt;http://nodejs.org/download/&lt;/a&gt; 找到相应的地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后将其的连接加入到 &lt;code&gt;/usr/bin&lt;/code&gt; 下即可。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;bin
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ln node /usr/bin
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ln npm /usr/bin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;： 该用 &lt;code&gt;sudo&lt;/code&gt; 的地方就用 &lt;code&gt;sudo&lt;/code&gt; 或者 &lt;code&gt;su&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至此，&lt;strong&gt;Linux&lt;/strong&gt; 下的 &lt;strong&gt;Node.js&lt;/strong&gt; 环境基本搭建完毕。&lt;/p&gt;
&lt;h2 id=&quot;windows-环境&quot;&gt;&lt;a href=&quot;#windows-环境&quot;&gt;2. Windows 环境&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;cygwin-安装和配置&quot;&gt;&lt;a href=&quot;#cygwin-安装和配置&quot;&gt;2.1. Cygwin 安装和配置&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Cygwin&lt;/em&gt;&lt;/strong&gt; 是一个在 &lt;strong&gt;&lt;em&gt;Windows&lt;/em&gt;&lt;/strong&gt; 平台上运行的 &lt;strong&gt;&lt;em&gt;Unix&lt;/em&gt;&lt;/strong&gt; 模拟环境。对于学习 &lt;strong&gt;&lt;em&gt;Unix/Linux&lt;/em&gt;&lt;/strong&gt; 操作环境，或者从 &lt;strong&gt;&lt;em&gt;Unix&lt;/em&gt;&lt;/strong&gt; 到 &lt;strong&gt;&lt;em&gt;Windows&lt;/em&gt;&lt;/strong&gt; 的应用程序移植，或者进行某些特殊的开发工作，尤其是使用 &lt;strong&gt;&lt;em&gt;GNU工具集&lt;/em&gt;&lt;/strong&gt; 在 &lt;strong&gt;&lt;em&gt;Windows&lt;/em&gt;&lt;/strong&gt; 上进行嵌入式系统开发，非常有用。&lt;/p&gt;
&lt;h4 id=&quot;cygwin-安装&quot;&gt;&lt;a href=&quot;#cygwin-安装&quot;&gt;2.1.1. Cygwin 安装&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;我们先跑到 &lt;strong&gt;Cygwin&lt;/strong&gt; 的官网上去把东西下来：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://cygwin.com/install.html&quot;&gt;http://cygwin.com/install.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，最好下 &lt;strong&gt;x86&lt;/strong&gt; 的包，因为我们之后要讲一个 &lt;code&gt;cyg-apt&lt;/code&gt; 的脚本插件，这是一个能让 &lt;strong&gt;Cygwin&lt;/strong&gt; 能跟 &lt;strong&gt;Linux&lt;/strong&gt; 一样通过脚本从源安装软件包的脚本。为了方便修改，我们将其下成 &lt;strong&gt;x86&lt;/strong&gt; 的版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后就是安装步骤了。&lt;/p&gt;
&lt;center&gt;
&lt;img src=&quot;http://blog-xcoder-in.qiniudn.com/cygwin-install-1.png&quot; alt=&quot;从网络安装&quot; /&gt;
&lt;/center&gt;
&lt;center&gt;
&lt;small&gt;[图2.1]&lt;/small&gt;
&lt;/center&gt;

&lt;p&gt;到 &lt;strong&gt;[图2.1]&lt;/strong&gt; 这个步骤的时候，选择默认的 &lt;code&gt;Install from Internet&lt;/code&gt; 即可。&lt;/p&gt;
&lt;center&gt;
&lt;img src=&quot;http://blog-xcoder-in.qiniudn.com/cygwin-install-2.png&quot; alt=&quot;选择安装路径&quot; /&gt;
&lt;/center&gt;
&lt;center&gt;
&lt;small&gt;[图2.2]&lt;/small&gt;
&lt;/center&gt;

&lt;p&gt;在 &lt;strong&gt;[图2.2]&lt;/strong&gt; 的时候选一个安装路径。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：尽可能让这个安装路径简单，而不要是类似于&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c:\Program Files\blahblah&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样的文件路径。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;center&gt;
&lt;img src=&quot;http://blog-xcoder-in.qiniudn.com/cygwin-install-3.png&quot; alt=&quot;本地包路径&quot; /&gt;
&lt;/center&gt;
&lt;center&gt;
&lt;small&gt;[图2.3]&lt;/small&gt;
&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;[图2.3]&lt;/strong&gt; 的时候选一个本地包的路径，我这里选的是 &lt;code&gt;e:\cygwin\tmp&lt;/code&gt;。&lt;/p&gt;
&lt;center&gt;
&lt;img src=&quot;http://blog-xcoder-in.qiniudn.com/cygwin-install-4.png&quot; alt=&quot;直连&quot; /&gt;
&lt;/center&gt;
&lt;center&gt;
&lt;small&gt;[图2.4]&lt;/small&gt;
&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;[图2.4]&lt;/strong&gt; 选择直接连接。&lt;/p&gt;
&lt;center&gt;
&lt;img src=&quot;http://blog-xcoder-in.qiniudn.com/cygwin-install-5.png&quot; alt=&quot;163&quot; /&gt;
&lt;/center&gt;
&lt;center&gt;
&lt;small&gt;[图2.5]&lt;/small&gt;
&lt;/center&gt;

&lt;p&gt;我们国内的用户源还是选择 &lt;code&gt;163&lt;/code&gt; 的速度比较快。所以在 &lt;strong&gt;[图2.5]&lt;/strong&gt; 这一步的时候就直接选用默认的 &lt;code&gt;163&lt;/code&gt; 的源了。如果不是默认的话，请选中它。&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;Select Package&lt;/strong&gt; 也就是选择预安装的软件的时候，把下列表中的软件包勾选起来：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;wget&lt;/strong&gt;: 在 &lt;strong&gt;Utils&lt;/strong&gt; 中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;vim&lt;/strong&gt;: 在 &lt;strong&gt;Editors&lt;/strong&gt; 中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gcc&lt;/strong&gt;: 在 &lt;strong&gt;Devel&lt;/strong&gt; 中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gcc-g++&lt;/strong&gt;: 在 &lt;strong&gt;Devel&lt;/strong&gt; 中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;make&lt;/strong&gt;: 在 &lt;strong&gt;Devel&lt;/strong&gt; 中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cmake&lt;/strong&gt;: 在 &lt;strong&gt;Devel&lt;/strong&gt; 中&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;若是这些选项已经被选起来了就不用再选了，如果没有选起来则把它选中。&lt;/p&gt;
&lt;p&gt;勾选好了之后就可以下一步安装了，直至安装完毕，你就可以打开你的 &lt;strong&gt;Cygwin&lt;/strong&gt; 了。&lt;/p&gt;
&lt;center&gt;
&lt;img src=&quot;http://blog-xcoder-in.qiniudn.com/cygwin-install-6.png&quot; alt=&quot;Cygwin&quot; /&gt;
&lt;/center&gt;
&lt;center&gt;
&lt;small&gt;[图2.6]&lt;/small&gt;
&lt;/center&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;：你可以点击窗口左上角的小图片，然后里面的 &lt;strong&gt;Options&lt;/strong&gt; 中，你可以调整你自己的 &lt;strong&gt;Cygwin&lt;/strong&gt; 外观。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;vim-配置&quot;&gt;&lt;a href=&quot;#vim-配置&quot;&gt;2.1.2. vim 配置&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;上一步我们已经选中了 &lt;strong&gt;vim&lt;/strong&gt; ，也就是说我们已经在 &lt;strong&gt;Cygwin&lt;/strong&gt; 中装上了 &lt;strong&gt;vim&lt;/strong&gt;。但是由于这里的 &lt;strong&gt;vim&lt;/strong&gt; 默认配置非常蛋疼，所以我们得改一下。&lt;/p&gt;
&lt;p&gt;在你的 &lt;strong&gt;Cygwin&lt;/strong&gt; 中一句句输入下面的命令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /home/&amp;lt;你自己的用户名&amp;gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;wget http://blog-xcoder-in.qiniudn.com/.vimrc
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;mkdir .vim
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; .vim
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;mkdir colors
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;colors
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;wget http://blog-xcoder-in.qiniudn.com/molokai.vim
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样你的 &lt;strong&gt;vim&lt;/strong&gt; 就用上了上面的那个地址的配置文件，当然你也可以编辑你自己的配置文件或者说从网上下别的配置文件以满足你的个性化需求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;vim&lt;/strong&gt; 配置以及使用请参照：&lt;a href=&quot;https://wiki.archlinux.org/index.php/Vim&quot;&gt;https://wiki.archlinux.org/index.php/Vim&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
事无巨细问 &lt;strong&gt;ArchWiki&lt;/strong&gt;。
&lt;div style=&quot;text-align: right;&quot;&gt;
&lt;em&gt;– &lt;a href=&quot;https://github.com/kalxd&quot;&gt;kalxd&lt;/a&gt;&lt;/em&gt;
&lt;/div&gt;

&lt;/blockquote&gt;
&lt;h3 id=&quot;apt-cyg&quot;&gt;&lt;a href=&quot;#apt-cyg&quot;&gt;2.1.3. apt-cyg&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;apt-cyg is a command-line installer for Cygwin which cooperates with Cygwin Setup and uses the same repository. The syntax is similar to apt-get.&lt;/p&gt;
&lt;div style=&quot;text-align: right;&quot;&gt;
&lt;em&gt;– From apt-cyg googlecode page&lt;/em&gt;
&lt;/div&gt;

&lt;/blockquote&gt;
&lt;p&gt;总之意思就是说 &lt;code&gt;apt-cyg&lt;/code&gt; 是类似于 &lt;strong&gt;Linux&lt;/strong&gt; 中的 &lt;code&gt;apt-get&lt;/code&gt;， &lt;code&gt;yum&lt;/code&gt;, &lt;code&gt;zypper&lt;/code&gt; 等命令行软件包安装器一样，可以通过&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;apt-cyg install &amp;lt;package names&amp;gt;&lt;/code&gt; 来安装软件包&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apt-cyg remove &amp;lt;package names&amp;gt;&lt;/code&gt; 来移除软件包&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apt-cyg update&lt;/code&gt; 来更新 setup.ini&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apt-cyg show&lt;/code&gt; 来列出已安装的软件包&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apt-cyg find &amp;lt;pattern(s)&amp;gt;&lt;/code&gt; 来查找符合条件的软件包&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apt-cyg describe &amp;lt;pattern(s)&amp;gt;&lt;/code&gt; 来描述符合条件的软件包&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apt-cyg packageof &amp;lt;commands or files&amp;gt;&lt;/code&gt; 来定位其父软件包&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;apt-cyg-安装&quot;&gt;&lt;a href=&quot;#apt-cyg-安装&quot;&gt;2.1.3.1. apt-cyg 安装&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;其实也不能说是安装，纯粹是把脚本从网络上拷到自己的 &lt;strong&gt;Cygwin&lt;/strong&gt; 的环境目录中。&lt;/p&gt;
&lt;p&gt;在你的 &lt;strong&gt;Cygwin&lt;/strong&gt; 中输入以下命令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /usr/local/bin
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;wget http://apt-cyg.googlecode.com/svn/trunk/apt-cyg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样你就“安装”好了 &lt;strong&gt;apt-cyg&lt;/strong&gt; 了。不过这里用的是默认的源，所有东西都是默认的。&lt;/p&gt;
&lt;p&gt;如果你现在已经心安理得或者不想折腾了可以跳过 &lt;strong&gt;&lt;a href=&quot;#apt-cyg-修改&quot;&gt;2.1.3.2. apt-cyg 修改&lt;/a&gt;&lt;/strong&gt;，如果你想把源换成 &lt;code&gt;163&lt;/code&gt; 的话那么稍微看一下吧。&lt;/p&gt;
&lt;h4 id=&quot;apt-cyg-修改&quot;&gt;&lt;a href=&quot;#apt-cyg-修改&quot;&gt;2.1.3.2. apt-cyg 修改&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;接下去我们要对 &lt;strong&gt;apt-cyg&lt;/strong&gt; 做一些编辑。&lt;/p&gt;
&lt;p&gt;你有下面两个选择：&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal&quot;&gt;
&lt;li&gt;如果你想学习 &lt;strong&gt;vim&lt;/strong&gt; 操作或者你已经熟悉了，那么直接使用 &lt;code&gt;vim apt-cyg&lt;/code&gt; 来进行编辑。&lt;/li&gt;
&lt;li&gt;如果你是懒人还是想要直接编辑的话，请跑到你的 &lt;strong&gt;Cygwin&lt;/strong&gt; 的安装目录，找到 &lt;strong&gt;usr&lt;/strong&gt; 文件夹，飞进 &lt;strong&gt;local/bin&lt;/strong&gt; 目录中去，用你自己喜欢的文本编辑器打开并编辑。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大约是 &lt;code&gt;68&lt;/code&gt; 行上下吧，有一句是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;  &lt;span class=&quot;nv&quot;&gt;mirror&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ftp://mirror.mcs.anl.gov/pub/cygwin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将其改成：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;  &lt;span class=&quot;nv&quot;&gt;mirror&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http://mirrors.163.com/cygwin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还有就是大概在 &lt;code&gt;98&lt;/code&gt; 行和 &lt;code&gt;105&lt;/code&gt; 行左右：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;    wget -N &lt;span class=&quot;nv&quot;&gt;$mirror&lt;/span&gt;/setup.bz2
    ...
    wget -N &lt;span class=&quot;nv&quot;&gt;$mirror&lt;/span&gt;/setup.ini
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改成：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;    wget -N &lt;span class=&quot;nv&quot;&gt;$mirror&lt;/span&gt;/x86/setup.bz2
    ...
    wget -N &lt;span class=&quot;nv&quot;&gt;$mirror&lt;/span&gt;/x86/setup.ini
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;至此，你的 &lt;strong&gt;Cygwin&lt;/strong&gt; 环境基本完成，以后可以再慢慢完善。&lt;/p&gt;
&lt;h3 id=&quot;node.js-安装&quot;&gt;&lt;a href=&quot;#node.js-安装&quot;&gt;2.2. Node.js 安装&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这个就很简单了，打开 &lt;strong&gt;&lt;a href=&quot;http://nodejs.org/download/&quot;&gt;Node.js&lt;/a&gt;&lt;/strong&gt; 官网下载安装即可。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;选择 &lt;strong&gt;Windows Installer (.msi)&lt;/strong&gt; 或者 &lt;strong&gt;Windows Binary (.exe)&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;安装好后就能直接在 &lt;strong&gt;Cygwin&lt;/strong&gt; 里面使用了。&lt;/p&gt;
&lt;h2 id=&quot;真hello-world&quot;&gt;&lt;a href=&quot;#真hello-world&quot;&gt;3. 真·Hello World&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;现在，无论你是 &lt;strong&gt;Linux&lt;/strong&gt; 用户还是 &lt;strong&gt;Windows&lt;/strong&gt; 用户，都可以用一样的步骤来完成下面的 &lt;code&gt;Hello World&lt;/code&gt; 了。&lt;/p&gt;
&lt;p&gt;随便跑一个目录里面新建一个文件并且用 &lt;strong&gt;vim&lt;/strong&gt; 编辑：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim hello.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在里面输入下面的东西：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;Hello world!&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后退出 &lt;strong&gt;vim&lt;/strong&gt; 执行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;node hello.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;终于，&lt;strong&gt;真·Hello world&lt;/strong&gt; 出现在了你的眼前，而不需要借助 &lt;strong&gt;&lt;a href=&quot;http://ideone.com/&quot;&gt;IDEOne&lt;/a&gt;&lt;/strong&gt; 了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;To be continued…&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>一起撸Node.JS（负叁）——概述</title>
   <link href="http://xadillax.github.io/node-learning/2013/08/13/node-1-summary"/>
   <updated>2013-08-13T00:00:00+08:00</updated>
   <id>http://xadillax.github.io/node-learning/2013/08/13/node-1-summary</id>
   <content type="html">&lt;p&gt;　　本系列教程主要是写给我带的那帮熊孩子们看的。我自己的 &lt;strong&gt;Node.js&lt;/strong&gt; 水平半斤八两，措辞之中也免不了有自己错误的理解，会误人子弟。但是对于初学者来说，某些自己助记的理解还是可取的。有些概念性的错误可以等他们进一步深入研究之后再自行更正。&lt;/p&gt;
&lt;p&gt;　　由于那帮人大多还处于使用 &lt;strong&gt;M$ Windows&lt;/strong&gt; 的令人不愉快的阶段，所以本教程将会退而求其次，使其在 &lt;strong&gt;Cygwin&lt;/strong&gt; 中模拟 &lt;strong&gt;linux&lt;/strong&gt; 的命令（Windows的bat脚本实在是让人不敢恭维）。以及在这里会讲述一些 &lt;strong&gt;Git&lt;/strong&gt; 操作的初步。当然，如果你已经在使用 &lt;strong&gt;linux&lt;/strong&gt; 进行开发的话，可以跳过前面一堆令人感到厌烦的环境配置章节。或者你在使用 &lt;strong&gt;M$ Windows&lt;/strong&gt; 但却不想改变自己的脚本习惯的话，也可以选择性地跳过一些章节和步骤。&lt;/p&gt;
&lt;!-- 我是小小分割符 --&gt;
&lt;h2 id=&quot;node.js是什么&quot;&gt;&lt;a href=&quot;#node.js是什么&quot;&gt;1. Node.JS是什么？&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;很多人都知道JS是一门语言，而且是一门脚本语言，其全称就是 &lt;strong&gt;JavaScript&lt;/strong&gt;，而且与所谓的 &lt;strong&gt;Java&lt;/strong&gt; 没有一个屁的关系。&lt;/p&gt;
&lt;h3 id=&quot;前端-javascript&quot;&gt;&lt;a href=&quot;#前端-javascript&quot;&gt;1.1 前端 JavaScript&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在好多年前，&lt;strong&gt;JavaScript&lt;/strong&gt; 是网页的一个寄生虫，它必须依赖于网页的浏览器中才能执行，并且作为网页的一部分，以&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//blahblah...&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;标签进行包含，这样才能提供其上下文环境。或者说将其单独写入一个 &lt;code&gt;*.js&lt;/code&gt; 文件中，并且在网页里以&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;foo/bar.js&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;的形式将其包含进来。&lt;/p&gt;
&lt;p&gt;但总而言之，&lt;strong&gt;JavaScript&lt;/strong&gt; 只是寄生在网页里面的一只小小可怜虫罢了。它的作用无非就是使网页的交互性更强，页面效果更多而已。&lt;/p&gt;
&lt;p&gt;后来，这帮不甘寂寞的人类将 &lt;strong&gt;JavaScript&lt;/strong&gt; 从网页（或者说前端）的帝国中独立了出来（小心快递），于是就出现了 &lt;strong&gt;CommonJS&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;commonjs&quot;&gt;&lt;a href=&quot;#commonjs&quot;&gt;1.2 CommonJS&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;CommonJS&lt;/strong&gt; 其实不是一门新的语言，甚至都不能说它是一个新的解释器——实际上它只是一个概念或者是一个规范。&lt;/p&gt;
&lt;p&gt;在这个规范中，它定义了很多 &lt;strong&gt;API&lt;/strong&gt; ，讲通俗点或者直截了当点就是函数啊类啊什么的，而这些 &lt;strong&gt;API&lt;/strong&gt; 是为那些普通应用程序（Native App）而非浏览器应用使用。它的终极目标就是提供一个类似于 &lt;strong&gt;Python&lt;/strong&gt;、&lt;strong&gt;Ruby&lt;/strong&gt; 之类的脚本一样的标准库，开发者可以用这样的东西一样来做到 &lt;strong&gt;Python&lt;/strong&gt;、&lt;strong&gt;Ruby&lt;/strong&gt; 能做到的事，而非仅仅局限于网页中的效果或者功能实现，它也可以跑在本地。&lt;/p&gt;
&lt;p&gt;所以说下面的事情对于 &lt;strong&gt;JavaScript&lt;/strong&gt; 来说不再是梦：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务端JavaScript应用&lt;/li&gt;
&lt;li&gt;命令行工具&lt;/li&gt;
&lt;li&gt;图形界面应用&lt;/li&gt;
&lt;li&gt;混合应用（Titanium、Adobe AIR等）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么，它具体弥补了 &lt;strong&gt;前端JavaScript&lt;/strong&gt; 的哪些空白呢？其实这也涉及了很多 &lt;strong&gt;前端JavaScript&lt;/strong&gt; 所没有涉及的东西，如二进制、编码、IO、文件、系统、断言测试、套接字、事件队列、Worker、控制台等等。&lt;/p&gt;
&lt;p&gt;关于 &lt;strong&gt;CommonJS&lt;/strong&gt; 的更进一步了解可以翻阅一下其 &lt;strong&gt;&lt;a href=&quot;http://wiki.commonjs.org/wiki/CommonJS&quot;&gt;Wiki&lt;/a&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;node.js&quot;&gt;&lt;a href=&quot;#node.js&quot;&gt;1.3 Node.JS&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;上面讲了那么多，却始终停留在“规范”这个层面上。而 &lt;strong&gt;Node.JS&lt;/strong&gt; 的出现便是让 &lt;strong&gt;CommonJS&lt;/strong&gt; 成为了现实。&lt;/p&gt;
&lt;p&gt;这里要大家明确的一点的就是 &lt;strong&gt;Node.JS&lt;/strong&gt; 并不是一门新的语言，它的语言还是 &lt;strong&gt;JavaScript&lt;/strong&gt; ，硬要说是一门新的语言那也应该是 &lt;strong&gt;Common JavaScript&lt;/strong&gt;。&lt;strong&gt;Node.JS&lt;/strong&gt; 只是 &lt;strong&gt;CommonJS&lt;/strong&gt; 的一个&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8&quot;&gt;解释器&lt;/a&gt;罢了。&lt;/p&gt;
&lt;p&gt;它是基于 &lt;strong&gt;Google&lt;/strong&gt; 的 &lt;strong&gt;V8虚拟机&lt;/strong&gt;(Chrome浏览器所使用的JavaScript执行环境) 的一个解释器。&lt;/p&gt;
&lt;p&gt;很多人印象中的概念还是没能摆脱 &lt;strong&gt;前端JavaScript&lt;/strong&gt; 的阴霾，认为 &lt;strong&gt;JavaScript&lt;/strong&gt; 就是做网站的， &lt;strong&gt;Node.JS&lt;/strong&gt; 也是如此。&lt;/p&gt;
&lt;p&gt;包括本人在 &lt;strong&gt;&lt;a href=&quot;http://cnodejs.org/&quot;&gt;cnodejs.org&lt;/a&gt;&lt;/strong&gt; 中看到的帖子大多也都是讲 &lt;strong&gt;Node.JS&lt;/strong&gt; 如何如何做网站（服务端）云云，如何如何使用 &lt;strong&gt;Express&lt;/strong&gt; 模块来搭建一个网站云云。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是一个误区。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;PHP&lt;/strong&gt; 还能用 &lt;strong&gt;&lt;a href=&quot;http://www.php-cli.com/&quot;&gt;PHP-CLI&lt;/a&gt;&lt;/strong&gt; 来写个脚本放本地跑呢，&lt;strong&gt;Node.JS&lt;/strong&gt; 更是可以写任何程序。虽然这么讲有些夸大了，但是我这么说的理由是希望大家能摆脱这么一个误区。&lt;/p&gt;
&lt;p&gt;举个简单的例子吧，大家都是搞过 &lt;strong&gt;ACM&lt;/strong&gt; 的孩子了，总对终端窗口的输入输出有一定感觉了吧。现在给我以最快速度码一个 &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://acm.nbut.edu.cn/problem/view.xhtml?id=1000&quot;&gt;A + B Problem&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; 给我看看。&lt;/p&gt;
&lt;p&gt;轻车熟路，我知道。但是你们现在做的事用 &lt;strong&gt;Node.JS&lt;/strong&gt; 同样能做到。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;resume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setEncoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;utf8&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;data&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;datas&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;trim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;datas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;datas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;trim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于&lt;del&gt;我们学校&lt;/del&gt;我的前任学校OJ不支持 &lt;strong&gt;Node.JS&lt;/strong&gt;，所以请你们移步到 &lt;strong&gt;&lt;a href=&quot;http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1000&quot;&gt;AIZU OJ&lt;/a&gt;&lt;/strong&gt; 去把上面的代码交过去看看结果看。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：语言要选择 &lt;strong&gt;JavaScript&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;怎么样，同样能过题的对吧？&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot;&gt;2. 小结&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;上面对这些东西做了个简单的介绍，我需要你们知道的东西很简单：&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal&quot;&gt;
&lt;li&gt;&lt;strong&gt;Node.JS&lt;/strong&gt; 是一个脚本解释器，用的语言是 &lt;strong&gt;JavaScript&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Node.JS&lt;/strong&gt; 功能很强大，不是只能拿来做网站的，眼光放开阔些。&lt;/li&gt;
&lt;li&gt;给我好好学。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;番外&quot;&gt;&lt;a href=&quot;#番外&quot;&gt;3. 番外&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;有个码畜老了，想学学书法来修身养性。当他展开宣纸，犹豫了半天之后，终于挥毫泼墨，在纸上龙飞凤舞写下几个大字：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Hello World&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然这一篇文章没有讲到任何 &lt;strong&gt;Node.JS&lt;/strong&gt; 的语法，但是还是可以让你们练练书法的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C语言&lt;/strong&gt; 的标准输出函数是 &lt;code&gt;printf&lt;/code&gt;，而 &lt;strong&gt;Node.JS&lt;/strong&gt; 的标准输出则是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;blahblah...&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;好的，即使没有装上 &lt;strong&gt;Node.JS&lt;/strong&gt; 环境也阻止不了我们向世界问好。&lt;/p&gt;
&lt;p&gt;打开 &lt;strong&gt;&lt;a href=&quot;http://ideone.com/&quot;&gt;IDEOne&lt;/a&gt;&lt;/strong&gt;，将你的 &lt;code&gt;Hello World&lt;/code&gt; 贴到编辑框中，然后在左侧的语言栏里面选中 &lt;strong&gt;Node.JS&lt;/strong&gt; ，点击送出，你就能看到你的第一个 &lt;strong&gt;Node.JS&lt;/strong&gt; 程序的运行结果了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;To be continued…&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>IOCP学习笔记（未完待续）</title>
   <link href="http://xadillax.github.io/programming/2013/08/08/iocp-learning-note"/>
   <updated>2013-08-08T00:00:00+08:00</updated>
   <id>http://xadillax.github.io/programming/2013/08/08/iocp-learning-note</id>
   <content type="html">&lt;p&gt;　　网络上大部分的讲解IOCP模型文章都比较断章取义，要么是这里冒出一个术语，那边出来一个不知名的名词。&lt;/p&gt;
&lt;p&gt;　　本文主要是给那些暂时还无太多的Windows编程基础的人阅读，里面解释了一些相应的前驱知识。比如管道、重叠I/O模型等等。&lt;/p&gt;
&lt;p&gt;　　如果你已经对这些了如指掌了，可以直接忽略本文——因为本文是给那些初学者看的。&lt;/p&gt;
&lt;p&gt;　　不过即使是给初学者看的，很多概念只是提个大概，让读者心里有个印象而已。更进一步的详细知识还是需要读者自行翻阅相关资料。&lt;/p&gt;
&lt;h2 id=&quot;前驱知识&quot;&gt;&lt;a href=&quot;#前驱知识&quot;&gt;前驱知识&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;管道&quot;&gt;&lt;a href=&quot;#管道&quot;&gt;管道&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;管道（PIPE）&lt;/strong&gt;是用于进程间通信的一段共享内存。创建管道的进程称为&lt;strong&gt;管道服务器&lt;/strong&gt;，连接到一个管道的进程称为&lt;strong&gt;管道客户机&lt;/strong&gt;。一个进程在向管道写入数据之后，另一个进程就可以从管道的另一端将其读出来。&lt;/p&gt;
&lt;p&gt;　　管道分两种，匿名管道和命名管道。&lt;/p&gt;
&lt;h4 id=&quot;匿名管道&quot;&gt;&lt;a href=&quot;#匿名管道&quot;&gt;匿名管道&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;　　匿名管道是在父进程和子进程间单向传输数据的一种未命名管道，只能在本地计算机中使用，而不能用于网络间通信。&lt;/p&gt;
&lt;p&gt;　　匿名管道由 &lt;code&gt;CreatePipe()&lt;/code&gt; 函数创建。该函数在创建匿名管道的同时返回两个句柄：读句柄和写句柄。其原型如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CreatePipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PHANDLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hReadPipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PHANDLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hWritePipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LPSECURITY_ATTRIBUTES&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpPipeAttributes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nSize&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;其中 &lt;code&gt;hReadPipe&lt;/code&gt; 为指向读句柄的指针， &lt;code&gt;hWritePipe&lt;/code&gt; 为指向写句柄的指针； &lt;code&gt;lpPipeAttributes&lt;/code&gt; 为指向安全属性的指针；最后的 &lt;code&gt;nSize&lt;/code&gt; 为管道大小，若为 &lt;code&gt;0&lt;/code&gt; 则由系统来决定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　匿名管道不支持异步读写操作。&lt;/p&gt;
&lt;h4 id=&quot;命名管道&quot;&gt;&lt;a href=&quot;#命名管道&quot;&gt;命名管道&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;　　命名管道是在管道服务器和一台或多台管道客户机之间进行单向或者双向通信的一种命名的管道。一个命名管道的所有实例都共享同一个管道名，但是每一个实例都拥有独立的缓存和句柄，并且为 &lt;code&gt;客户机 - 服务器&lt;/code&gt; 通信提供一个分离的管道。&lt;/p&gt;
&lt;p&gt;　　命名管道可以在同一台计算机的不同进程之间或者跨越一个网络的不同计算机的不同进程间进行有连接的可靠数据通信。如果连接中断，连接双方都能立即受到连接断开的信息。&lt;/p&gt;
&lt;p&gt;　　每个命名管道都有一个唯一的名字，以区分存在于系统的命名对象列表中的其它命名管道。管道服务器在调用 &lt;code&gt;CreateNamedPipe()&lt;/code&gt; 函数创建管道的一个或多个实例时为其指定了名称。对于管道客户机，则是在调用 &lt;code&gt;CreateFile()&lt;/code&gt; 或 &lt;code&gt;CallNamedPipe()&lt;/code&gt; 函数在连接一个命名管道实例时对管道名进行指定。&lt;/p&gt;
&lt;p&gt;　　命名管道对其标识采用 &lt;code&gt;UNC格式&lt;/code&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;\\Server\Pipe\[Path]Name&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　其中第一部分 &lt;code&gt;\\Server&lt;/code&gt; 指定了服务器的名字，命名管道服务就在此服务器创建。其字符串部分可以为一个小数点（表示本机）、星号（当前网络字段）、域名或者是一个真正的服务；第二部分是一个不可变化的硬编码字符串；第三部分 &lt;code&gt;\[Path]Name&lt;/code&gt; 则使应用程序可以唯一定义及标识一个命名管道的名字，而且可以设置多级目录。&lt;/p&gt;
&lt;p&gt;　　管道服务器首次调用 &lt;code&gt;CreateNamedPipe()&lt;/code&gt; 函数时，使用 &lt;code&gt;nMaxInstance&lt;/code&gt; 参数指定了能同时存在的管道实例的最大数目。服务器可以重复调用 &lt;code&gt;CreateNamedPipe()&lt;/code&gt; 函数去创建新的管道实例，直至达到设定的最大实例数。&lt;/p&gt;
&lt;p&gt;　　下面给出 &lt;code&gt;CreateNamedPipe()&lt;/code&gt; 的函数原型：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;HANDLE&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CreateNamedPipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LPCTSTR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dwOpenMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dwPipeMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nMaxInstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nOutBufferSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nInBufferSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nDefaultTimeOut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LPSECURITY_ATTRIBUTES&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpSecurityAttributes&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;这里的 &lt;code&gt;lpName&lt;/code&gt; 就是所谓的管道名称指针了， &lt;code&gt;dwOpenMode&lt;/code&gt; 为管道打开的模式（用来指示管道在创建好之后，它的传输方向、I/O控制以及安全模式）， &lt;code&gt;dwPipeMode&lt;/code&gt; 为管道模式， &lt;code&gt;nMaxInstance&lt;/code&gt; 正如之前所说的是最大的管道实例数， &lt;code&gt;nOutBufferSize&lt;/code&gt; 为输出缓存的大小， &lt;code&gt;nInBufferSize&lt;/code&gt; 为输入缓存的大小， &lt;code&gt;nDefaultTimeOut&lt;/code&gt; 为超时设置，最后的 &lt;code&gt;lpSecurityAttributes&lt;/code&gt; 为安全属性的指针。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;createfile-readfile等api&quot;&gt;&lt;a href=&quot;#createfile-readfile等api&quot;&gt;CreateFile, ReadFile等API&lt;/a&gt;&lt;/h3&gt;
&lt;h4 id=&quot;createfile&quot;&gt;&lt;a href=&quot;#createfile&quot;&gt;CreateFile()&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;　　这个函数可以创建或者打开一个对象的句柄，凭借此句柄我们就可以控制这些对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制台对象&lt;/li&gt;
&lt;li&gt;通信资源对象&lt;/li&gt;
&lt;li&gt;目录对象（只能打开）&lt;/li&gt;
&lt;li&gt;磁盘设备对象&lt;/li&gt;
&lt;li&gt;文件对象&lt;/li&gt;
&lt;li&gt;邮槽对象&lt;/li&gt;
&lt;li&gt;管道对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　函数原型：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;HANDLE&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CreateFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LPCTSTR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dwDesiredAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dwShareMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LPSECURITY_ATTRIBUTES&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpSecurityAttributes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dwCreationDisposition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dwFlagsAndAttributes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;HANDLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hTemplateFile&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;参数解析&lt;/strong&gt;&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;lpFileName：&lt;/em&gt;&lt;/strong&gt; 一个指向无终结符的字符串指针，用来指明要创建或者打开的对象的名字。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;dwDesiredAccess：&lt;/em&gt;&lt;/strong&gt; 指明对象的控制模式。一个应用程序可以包含读控制、写控制、读/写控制、设备查询控制。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;dwShareMode：&lt;/em&gt;&lt;/strong&gt; 指定对象的共享模式。如果 &lt;code&gt;dwShareMode == 0&lt;/code&gt; 则表示是互斥使用的。如果 &lt;code&gt;CreateFile&lt;/code&gt; 打开成功，则别的程序只能等到当前程序关闭对象句柄 &lt;code&gt;CloseHandle&lt;/code&gt; 后才能再打开或者使用。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;lpSecurityAttributes：&lt;/em&gt;&lt;/strong&gt; 一个指向 &lt;code&gt;SECURITY_ATTRIBUTES&lt;/code&gt; 结构对象的指针，决定返回的句柄是否被子进程所继承。如果 &lt;code&gt;lpSecurityAttributes&lt;/code&gt; 参数为 &lt;code&gt;NULL&lt;/code&gt; ，句柄就不能被子进程继承。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;dwCreationDisposition：&lt;/em&gt;&lt;/strong&gt; 指明当打开的对象存在或不存在的时候各需要怎么样去处理。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;dwFlagsAndAttributes：&lt;/em&gt;&lt;/strong&gt; 指定文件属性和标志。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;hTemplateFile：&lt;/em&gt;&lt;/strong&gt; 把具有 &lt;code&gt;GENERIC_READ&lt;/code&gt; 权限的句柄指定为一个模板文件。这个模板文件提供了文件属性和扩展属性，用于创建文件。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果调用成功，返回值是一个打开文件的句柄。&lt;/p&gt;
&lt;p&gt;如果调用之前文件已经存在，且 &lt;code&gt;dwCreationDisposition&lt;/code&gt; 参数为 &lt;code&gt;CREATE_ALWAYS&lt;/code&gt; 或者 &lt;code&gt;OPEN_AWAYS&lt;/code&gt; ，用 &lt;code&gt;GetLastError&lt;/code&gt; 返回 &lt;code&gt;ERROR_ALREADY_EXISTS&lt;/code&gt; （即使调用成功也会返回这个值）。如果调用之前不存在 &lt;code&gt;GetLastError&lt;/code&gt; 返回 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如果调用失败，返回值是 &lt;code&gt;INVALID_HANDLE_VALUE&lt;/code&gt; 。要进一步了解出错原因，调用 &lt;code&gt;GetLastError&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;closehandle&quot;&gt;&lt;a href=&quot;#closehandle&quot;&gt;CloseHandle()&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;　　用于关掉一个打开的对象句柄。&lt;/p&gt;
&lt;p&gt;　　函数原型如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CloseHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;HANDLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hObject&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h4 id=&quot;readfile&quot;&gt;&lt;a href=&quot;#readfile&quot;&gt;ReadFile()&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;　　&lt;code&gt;ReadFile()&lt;/code&gt; 函数从文件指针指定的位置读取数据。读操作完毕之后，文件指针将根据实际读出的数据自动进行调整，除非文件句柄是以 &lt;code&gt;OVERLAPPED&lt;/code&gt; 属性值打开的。如果是以 &lt;code&gt;OVERLAPPED&lt;/code&gt; 打开的I/O，应用程序就需要自己手动调整文件指针。&lt;/p&gt;
&lt;p&gt;　　这个函数被设计成兼有同步和异步操作。 &lt;code&gt;ReadFileEx()&lt;/code&gt; 函数则设计成只支持异步操作，异步操作允许应用程序在读文件期间可以同时进行其它的操作。&lt;/p&gt;
&lt;p&gt;　　函数原型：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ReadFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;HANDLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LPVOID&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nNumberOfBytesToRead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LPDWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpNumberOfBytesRead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LPOVERLAPPED&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpOverlapped&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;参数解析&lt;/strong&gt;&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;hFile：&lt;/em&gt;&lt;/strong&gt; 文件句柄（必须具有 &lt;code&gt;GENERIC_READ&lt;/code&gt; 访问权限）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;lpBuffer：&lt;/em&gt;&lt;/strong&gt; 用来接收从文件中读出的数据的缓冲区。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;nNumberOfBytesToRead：&lt;/em&gt;&lt;/strong&gt; 指明要读取的字节总数。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;lpNumberOfBytesRead：&lt;/strong&gt;&lt;/em&gt; 一个变量指针，用来存储实际传输的字节总数。 &lt;code&gt;ReadFile&lt;/code&gt; 在做所有事情（包括错误检查）之前，先将这个值赋为 &lt;code&gt;0&lt;/code&gt;。当 &lt;code&gt;ReadFile&lt;/code&gt; 从一个命名管道上返回 &lt;code&gt;TRUE&lt;/code&gt; 时这个参数为 &lt;code&gt;0&lt;/code&gt; ，说明消息管道另一端调用 &lt;code&gt;WriteFile&lt;/code&gt; 时设置的 &lt;code&gt;nNumberOfBytesToWrite&lt;/code&gt; 参数为 &lt;code&gt;0&lt;/code&gt; 。如果 &lt;code&gt;lpOverlapped&lt;/code&gt; 不是 &lt;code&gt;NULL&lt;/code&gt; ， &lt;code&gt;lpNumberOfBytesRead&lt;/code&gt; 可以设置为 &lt;code&gt;NULL&lt;/code&gt; 。如果是一个 &lt;code&gt;Overlapped&lt;/code&gt; 形式的读操作，我们可以动用 &lt;code&gt;GetOverlappedResult&lt;/code&gt; 函数来获得传输的实际字节数。如果 &lt;code&gt;hFile&lt;/code&gt; 关联的是一个&lt;strong&gt;完成端口（I/O Completion Port）&lt;/strong&gt;，那么可以调用 &lt;code&gt;GetQueuedCompletionStatus&lt;/code&gt; 函数来获得传输的实际字节数。如果完成端口被占用，而你用的是一个用于释放内存的回调例程，对于 &lt;code&gt;lpOverlapped&lt;/code&gt; 参数指向的 &lt;code&gt;OVERLAPPED&lt;/code&gt; 结构体来说，为这个参数指定 &lt;code&gt;NULL&lt;/code&gt; 可以避免重新分配内存时发生内存泄露。内存泄露会导致返回这个参数值时是一个非法值。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;lpOverlapped：&lt;/em&gt;&lt;/strong&gt; 一个指向 &lt;code&gt;OVERLAPPED&lt;/code&gt; 结构体的指针。如果 &lt;code&gt;hFile&lt;/code&gt; 是以 &lt;code&gt;FILE_FLAG_OVERLAPPED&lt;/code&gt; 方式获得的句柄，这个结构是必须的，不能为 &lt;code&gt;NULL&lt;/code&gt; （否则函数会在错误的时刻报告读操作已经完成了）。这时，读操作在由 &lt;code&gt;OVERLAPPED&lt;/code&gt; 中 &lt;code&gt;Offset&lt;/code&gt; 成员指定的偏移地址开始读，并且在实际完成读操作之前就返回了。在这种情况下， &lt;code&gt;ReadFile&lt;/code&gt; 返回 &lt;code&gt;FALSE&lt;/code&gt; ， &lt;code&gt;GetLastError&lt;/code&gt; 报告的错误类型是 &lt;code&gt;ERROR_IO_PENDING&lt;/code&gt; 。这允许调用进程继续其它工作直到读操作完成。 &lt;code&gt;OVERLAPPED&lt;/code&gt; 结构中的事件将会在读操作完成时被使用。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有如下任一种情况发生都会导致函数返回：&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal&quot;&gt;
&lt;li&gt;在管道另一端的写操作完成后。&lt;/li&gt;
&lt;li&gt;请求的字节数传输完毕。&lt;/li&gt;
&lt;li&gt;发生错误。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果函数正确，返回非零。&lt;/p&gt;
&lt;p&gt;如果返回值是非零但接受的字节数为 &lt;code&gt;0&lt;/code&gt; ，那么可能是文件指针在读操作期间超出了文件的 &lt;code&gt;end&lt;/code&gt; 位置。然而如果文件以 &lt;code&gt;FILE_FLAG_OVERLAPPED&lt;/code&gt; 方式打开， &lt;code&gt;lpOverlapped&lt;/code&gt; 参数不为 &lt;code&gt;NULL&lt;/code&gt; ，文件指针在读操作期间超出了文件的 &lt;code&gt;end&lt;/code&gt; 位置，那么返回值肯定是 &lt;code&gt;FALSE&lt;/code&gt; ， &lt;code&gt;GetLastError&lt;/code&gt; 返回的错误是 &lt;code&gt;ERROR_HANDLE_EOF&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;writefile&quot;&gt;&lt;a href=&quot;#writefile&quot;&gt;WriteFile&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;　　可以以同步或异步方式向一个对象句柄中写数据。&lt;/p&gt;
&lt;p&gt;　　函数原型：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WriteFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;HANDLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LPCVOID&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nNumberOfBytesToWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LPDWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpNumberOfBytesWritten&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LPOVERLAPPED&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpOverlapped&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　其它信息与 &lt;code&gt;ReadFile&lt;/code&gt; 极其相似，可以参考 &lt;code&gt;ReadFile&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;winsock重叠io模型&quot;&gt;&lt;a href=&quot;#winsock重叠io模型&quot;&gt;Winsock重叠I/O模型&lt;/a&gt;&lt;/h3&gt;
&lt;h4 id=&quot;重叠io模型的概念&quot;&gt;&lt;a href=&quot;#重叠io模型的概念&quot;&gt;重叠I/O模型的概念&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;　　当调用 &lt;code&gt;ReadFile()&lt;/code&gt; 和 &lt;code&gt;WriteFile()&lt;/code&gt; 时，如果最后一个参数 &lt;code&gt;lpOverlapped&lt;/code&gt; 设置为 &lt;code&gt;NULL&lt;/code&gt; ，那么线程就阻塞在这里，知道读写完指定的数据后，它们才会返回。这样在读写大文件的时候，很多时间都浪费在等待 &lt;code&gt;ReadFile()&lt;/code&gt; 和 &lt;code&gt;WriteFile()&lt;/code&gt; 的返回上面。如果 &lt;code&gt;ReadFile()&lt;/code&gt; 和 &lt;code&gt;WriteFile()&lt;/code&gt; 是往管道里面读写数据，那么有可能阻塞更久，导致程序性能下降。&lt;/p&gt;
&lt;p&gt;　　为了解决这个问题，Windows引进了&lt;strong&gt;重叠I/O&lt;/strong&gt;的概念，它能够同时以多个线程处理多个I/O。其实你自己开多个线程也可以处理多个I/O，但是系统内部对I/O的处理在性能上有很大的优化。它是Windows下实现异步I/O的最常用的方式。&lt;/p&gt;
&lt;p&gt;　　Windows为几乎全部类型的文件提供这个工具：磁盘文件、通信端口、命名管道和套接字。通常，使用 &lt;code&gt;ReadFile()&lt;/code&gt; 和 &lt;code&gt;WriteFile()&lt;/code&gt; 就可以很好地执行重叠I/O。&lt;/p&gt;
&lt;p&gt;　　重叠模型的核心是一个重叠数据结构。若想以重叠方式使用文件，必须用 &lt;code&gt;FILE_FLAG_OVERLAPPED&lt;/code&gt; 标志打开它，例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;HANDLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hFile&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CreateFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lpFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;GENERIC_READ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GENERIC_WRITE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;FILE_SHARE_READ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FILE_SHARE_WRITE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;OPEN_EXISTING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;FILE_FLAG_OVERLAPPED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　如果没有规定该标志，则针对这个文件（句柄），重叠I/O是不可用的。如果设置了该标志，当调用 &lt;code&gt;ReadFile()&lt;/code&gt; 和 &lt;code&gt;WriteFile()&lt;/code&gt; 操作这个文件（句柄）时，必须为最后一个参数提供 &lt;code&gt;OVERLAPPED&lt;/code&gt; 结构：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// WINBASE.H&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_OVERLAPPED&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;Internal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;InternalHigh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;Offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;OffsetHigh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;HANDLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OVERLAPPED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LPOVERLAPPED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　头两个32位的结构字 &lt;code&gt;Internal&lt;/code&gt; 和 &lt;code&gt;InternalHigh&lt;/code&gt; 由系统内部使用；其次两个32位结构字 &lt;code&gt;Offset&lt;/code&gt; 和 &lt;code&gt;OffsetHigh&lt;/code&gt; 使得可以设置64位的偏移量，该偏移量是要文件中读或写的地方。&lt;/p&gt;
&lt;p&gt;　　因为I/O异步发生，就不能确定操作是否按顺序完成。因此，这里没有当前位置的概念。对于文件的操作，总是规定该偏移量。&lt;strong&gt;在数据流下（如COM端口或socket），没有寻找精确偏移量的方法，所以在这些情况中，系统忽略偏移量&lt;/strong&gt;。这四个字段不应由应用程序直接进行处理或使用， &lt;code&gt;OVERLAPPED&lt;/code&gt; 结构的最后一个参数是可选的事件句柄，当I/O完成时，该事件对象受信（signaled）。程序通过等待该对事件对象受信来做善后处理。&lt;/p&gt;
&lt;p&gt;　　设置了 &lt;code&gt;OVERLAPPED&lt;/code&gt; 参数后， &lt;code&gt;ReadFile()&lt;/code&gt; / &lt;code&gt;WriteFile()&lt;/code&gt; 的调用会立即返回，这时候你可以去做其他的事（所谓异步），系统会自动替你完成 &lt;code&gt;ReadFile()&lt;/code&gt; / &lt;code&gt;WriteFile()&lt;/code&gt; 相关的I/O操作。你也可以同时发出几个 &lt;code&gt;ReadFile()&lt;/code&gt; / &lt;code&gt;WriteFile()&lt;/code&gt; 的调用（所谓重叠）。当系统完成I/O操作时，会将 &lt;code&gt;OVERLAPPED.hEvent&lt;/code&gt; 置信，我们可以通过调用 &lt;code&gt;WaitForSingleObject&lt;/code&gt; / &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; 来等待这个I/O完成通知，在得到通知信号后，就可以调用 &lt;code&gt;GetOverlappedResult&lt;/code&gt; 来查询I/O操作的结果，并进行相关处理。由此可以看出， &lt;code&gt;OVERLAPPED&lt;/code&gt; 结构在一个重叠I/O请求的初始化及其后续的完成之间，提供了一种沟通或通信机制。注意 &lt;code&gt;OVERLAPPED&lt;/code&gt; 结构的生存周期，一般动态分配，待I/O完成后，回收重叠结构。&lt;/p&gt;
&lt;p&gt;　　以Win32重叠I/O机制为基础，自&lt;strong&gt;WinSock 2&lt;/strong&gt;发布开始，重叠I/O便已集成到新的&lt;strong&gt;WinSock API&lt;/strong&gt;中，比如 &lt;code&gt;WSARecv()&lt;/code&gt; / &lt;code&gt;WSASend()&lt;/code&gt; 。这样一来，重叠I/O模型便能适用于安装了&lt;strong&gt;WinSock 2&lt;/strong&gt;的所有Windows平台。可以一次投递一个或多个WinSock I/O请求。针对那些提交的请求，在它们完成之后，应用程序可为它们提供服务（对I/O的数据进行处理）。&lt;/p&gt;
&lt;p&gt;　　相应的，要像在一个套接字上使用重叠I/O模型来处理网络数据通信，首先必须使用 &lt;code&gt;WSA_FLAG_OVERLAPPED&lt;/code&gt; 这个标志来创建一个套接字，如下所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;SOCKET&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WSASocket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AF_INET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SOCK_STEAM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WSA_FLAG_OVERLAPPED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　创建套接字的时候，加入使用的是 &lt;code&gt;Socket()&lt;/code&gt; 函数而非 &lt;code&gt;WSASocket()&lt;/code&gt; 函数，那么会默认设置 &lt;code&gt;WSA_FLAG_OVERLAPPED&lt;/code&gt; 标志。成功创建好了一个套接字，将其与本地接口绑定到一起以后，便可以开始进行这个套接字上的重叠I/O操作，方法是调用下述的Winsock 2函数，同时为他们制定一个 &lt;code&gt;WSAOVERLAPPED&lt;/code&gt; 结构参数（&lt;code&gt;#define WSAOVERLAPPED OVERLAPPED // WINSOCK2.H&lt;/code&gt;）：&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal&quot;&gt;
&lt;li&gt;&lt;code&gt;WSASend()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WSASendTo()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WSARecv()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WSARecvFrom()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WSAIoctl()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AcceptEx()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TransmitFile()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　若随一个 &lt;code&gt;WSAOVERLAPPED&lt;/code&gt; 结构一起调用这些函数，函数会立即返回，无论套接字是否设为锁定模式。他们依赖于 &lt;code&gt;WSAOVERLAPPED&lt;/code&gt; 结构来返回一个I/O请求操作的结果。&lt;/p&gt;
&lt;p&gt;　　比起&lt;strong&gt;阻塞&lt;/strong&gt;、&lt;strong&gt;select&lt;/strong&gt;、&lt;strong&gt;WSAAsyncSelect&lt;/strong&gt;以及&lt;strong&gt;WSAEventSelect&lt;/strong&gt;等模型，&lt;strong&gt;Winsock&lt;/strong&gt;的重叠I/O模型使应用程序能达到更佳的系统性能。因为它和着四种模型不同的是，使用重叠模型的应用程序通知缓冲区收发系统直接使用数据。也就是说，如果应用程序投递了一个&lt;strong&gt;&lt;em&gt;10KB&lt;/em&gt;&lt;/strong&gt;大小的缓冲区来接收数据，且数据已经到达套接字，则该数据将直接被拷贝到投递的缓冲区。而这4种模型中，数据到达并拷贝到单套接字接收缓冲区（Per Socket Buffer）中，此时应用程序会被系统通知可以读入的字节数。当应用程序调用接收函数之后，数据才从单套接字缓冲区拷贝到应用程序的缓冲区。这样就减少了一次从I/O缓冲区到应用程序缓冲区的拷贝，差别就在于此。&lt;/p&gt;
&lt;p&gt;　　实际编程时，可以投递一个0字节缓冲区的 &lt;code&gt;WSARecv&lt;/code&gt; / &lt;code&gt;WSASend&lt;/code&gt; 操作，这样就没有用户缓冲区与I/O操作相关联，避免了用户缓冲区的锁定（过多的锁定可能导致非分页内存池耗尽，即 &lt;code&gt;WSAENOBUFS&lt;/code&gt; ），应用程序绕开单套接字缓冲区而直接与&lt;strong&gt;TCP Stack&lt;/strong&gt;进行数据交互，从而避免了内存拷贝。当然，只要投递了足够多的重叠发送/接收操作，就能避免额外的内存拷贝，这时将单套接字缓冲区设置为0并不能提升性能。因为应用程序的发送缓冲区将始终被锁定直到可以下传给TCP，所以停用套接字的发送缓冲区对性能的影响比停用接收缓冲区小。然而，如果接收缓冲区被设置为0，而又未投递重叠接收操作，则进来的数据都只能停留在TCP Stack中，而TCP驱动程序的缓冲区最多只能接收窗口大小。TCP缓冲区被定位在非分页内存池中，假如很多连接发数据过来，但我们根本没有投递接收操作，则将消耗大量的非分页内存池。非分页内存池是一种有限的资源，过多的锁定可能导致非分页内存池耗尽，即 &lt;code&gt;WSAENOBUFS&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;　　在Windows NT和Windows 2000中，模重叠I/O型也允许应用程序以一种重叠方式实现对套接字连接的处理。具体的做法是在监听套接字上调用 &lt;code&gt;AcceptEx&lt;/code&gt; 函数。 &lt;code&gt;AcceptEx&lt;/code&gt; 是一个特殊的WinSock扩展函数，由&lt;strong&gt;mswsock.dll&lt;/strong&gt;实现，使用时需包含&lt;strong&gt;Mswsock.h&lt;/strong&gt;头文件，链接&lt;strong&gt;Mswsock.lib&lt;/strong&gt;库文件。该函数最初的设计宗旨是在Windows NT与Windows 2000操作系统上使用Win 32的重叠I/O机制。但事实上，它也适用于WinSock 2中的重叠I/O。 &lt;code&gt;AcceptEx&lt;/code&gt; 的定义如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// MSWSOCK.H&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;AcceptEx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SOCKET&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sListenSocket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SOCKET&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sAcceptSocket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PVOID&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpOutputBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dwReceiveDataLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dwLocalAddressLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dwRemoteAddressLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;OUT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LPDWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpdwBytesReceived&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LPOVERLAPPED&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpOverlapped&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;参数解析&lt;/strong&gt;&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;sListenSocket：&lt;/em&gt;&lt;/strong&gt; 指定的是一个监听套接字。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;sAcceptSocket：&lt;/em&gt;&lt;/strong&gt; 指定的是另一个套接字，负责对进入连接请求的“接受”。 &lt;code&gt;AcceptEx()&lt;/code&gt; 函数和 &lt;code&gt;accept()&lt;/code&gt; 函数的区别在于，我们必须提供接受的套接字，而不是让函数自动为我们创建。正是由于要提供套接字，所以要求我们事先调用 &lt;code&gt;socket()&lt;/code&gt; 或者 &lt;code&gt;WSASocket()&lt;/code&gt; 函数创建一个套接字，以便通过 &lt;code&gt;sAcceptSocket&lt;/code&gt; 参数，将其传递给 &lt;code&gt;AcceptEx()&lt;/code&gt; 。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;lpOutputBuffer：&lt;/em&gt;&lt;/strong&gt; 指定的是一个特殊的缓冲区，因为它要负责三种数据的接收：服务器的本地地址，客户机的远程地址，以及在新建连接上接收的第一个数据块。存储顺序是： &amp;gt; 接收到的数据块→本地地址→远程地址&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;dwReceiveDataLength：&lt;/em&gt;&lt;/strong&gt; 以字节为单位，指定了在 &lt;code&gt;lpOutputBuffer&lt;/code&gt; 缓冲区开头保留多大的空间，用于数据的接收。如果这个参数设为 &lt;code&gt;0&lt;/code&gt; ，那么只接受连接，不伴随接受数据。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;dwLocalAddressLength/dwRemoteAddressLength：&lt;strong&gt;* 以字节为单位，指定在 &lt;code&gt;lpOutputBuffer&lt;/code&gt; 缓冲区中，保留多大空间，在一个套接字被接受的时候，用于本地和远程地址信息的保存。要注意的是，和当前采用的传送协议允许的最大地址长度比较起来，这里指定的缓冲区大小至少应多出 &lt;code&gt;16字节&lt;/code&gt; 。举个例子来说，假设正在使用的是&lt;/strong&gt;&lt;/em&gt;TCP/IP&lt;/strong&gt;*协议，那么这里的大小应该设为 &lt;code&gt;sizeof(SOCKADDR_IN) + 16&lt;/code&gt; 。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;lpdwBytesReceived：&lt;/em&gt;&lt;/strong&gt; 用于返回接收到的实际数据量。以字节为单位。只有在操作以同步方式完成的前提下，才会设置i这个参数加入 &lt;code&gt;AcceptEx()&lt;/code&gt; 函数返回 &lt;code&gt;ERROR_IO_PENDING&lt;/code&gt; ，那么这个参数永远都不会设置，我们必须利用完成事件通知机制，获知实际读取的字节量。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;lpOverlapped：&lt;/em&gt;&lt;/strong&gt; 它对应的是一个 &lt;code&gt;OVERLAPPED&lt;/code&gt; 结构，允许 &lt;code&gt;AcceptEx()&lt;/code&gt; 以一种异步方式工作。如我们早先所述，只有在一个重叠I/O应用中，该函数才需要使用事件对象通知机制（&lt;code&gt;hEvent&lt;/code&gt; 字段），这是由于此时没有一个完成例程参数可供使用。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;获取重叠io操作完成结果&quot;&gt;&lt;a href=&quot;#获取重叠io操作完成结果&quot;&gt;获取重叠I/O操作完成结果&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;　　当异步I/O请求挂起之后，最终要知道I/O操作是否完成。一个重叠I/O请求最终完成后，应用程序要负责读取重叠I/O操作的结果。对于读，直到I/O完成，接收缓冲器才有效；对于写，要知道是否成功，有几种方法可以做到这点，最直接的方法是调用 &lt;code&gt;(WSA)GetOverlappedResult&lt;/code&gt; ，其函数原型如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;WINBASEAPI&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WINAPI&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetOverlappedResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;HANDLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LPOVERLAPPED&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpOverlapped&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LPDWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpNumberOfBytesTransferred&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bWait&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WSAGetOverlappedResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SOCKET&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LPWSAOVERLAPPED&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpOverlapped&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LPDWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpcbTransfer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fWait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LPDWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpdwFlags&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;参数解析&lt;/strong&gt;&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;参数一：&lt;/em&gt;&lt;/strong&gt; 文件/套接字句柄。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;参数二：&lt;/em&gt;&lt;/strong&gt; 参数一关联的 &lt;code&gt;(WSA)OVERLAPPED&lt;/code&gt; 结构，在调用 &lt;code&gt;CreateFile()&lt;/code&gt; 、 &lt;code&gt;WSASocket()&lt;/code&gt; 或者 &lt;code&gt;AcceptEx()&lt;/code&gt; 时指定。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;参数三：&lt;/em&gt;&lt;/strong&gt; 指向字节计数指针，负责接收一次重叠发送或者接收操作实际传输的字节数。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;参数四：&lt;/em&gt;&lt;/strong&gt; 确定命令是否等待的标志。 &lt;code&gt;bWait&lt;/code&gt; 参数用于决定函数是否应该等待一次重叠操作完成。若将 &lt;code&gt;bWait&lt;/code&gt; 设置为 &lt;code&gt;TRUE&lt;/code&gt; ，那么知道操作完成函数才返回；若设为 &lt;code&gt;FALSE&lt;/code&gt; ，而且操作仍然处于未完成状态，那么 &lt;code&gt;(WSA)GetOverlappedResult()&lt;/code&gt; 函数会返回 &lt;code&gt;FALSE&lt;/code&gt; 值。如 &lt;code&gt;(WSA)GetOverlappedResult()&lt;/code&gt; 函数调用成功，返回值就是 &lt;code&gt;TRUE&lt;/code&gt; 。这意味着我们的重叠I/O操作已经成功完成，而且由参数三 &lt;code&gt;lpNumberOfBytesTransferred&lt;/code&gt; 指向的值已进行了更新。若返回值是 &lt;code&gt;FALSE&lt;/code&gt; ，那么可能是由下述任何一种原因造成的：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;重叠I/O操作仍处在“待决”状态。&lt;/li&gt;
&lt;li&gt;重叠操作已经完成，但含有错误。&lt;/li&gt;
&lt;li&gt;重叠操作的完成状态不可判决，因为在提供给 &lt;code&gt;WSAGetOverlappedResult&lt;/code&gt; 函数的一个或多个参数中，存在着错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;失败后，由 &lt;code&gt;lpNumberOfBytesTransferred&lt;/code&gt; 参数指向的值不会进行更新，而且我们的应用程序调用 &lt;code&gt;(WSA)GetLastError()&lt;/code&gt; 函数，检查到底是何种原因造成了调用失败以使用相应答错处理。如果错误码为 &lt;code&gt;SOCKET_ERROR/WSA_IO_INCOMPLETE (Overlapped I/O event is not in a signaled state)&lt;/code&gt; 或者 &lt;code&gt;SOCKET_ERROR/WSA_IO_PENDING (Overlapped I/O operation is in progress)&lt;/code&gt; ，则表明I/O仍在进行。当然这不是真正错误，任何其它错误码则真正表明一个实际错误。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
 </entry>
 
 <entry>
   <title>关于JavaScript中callback函数的this指针重定义</title>
   <link href="http://xadillax.github.io/programming/2013/07/15/javascript-in-function-this-pointer-repoint"/>
   <updated>2013-07-15T00:00:00+08:00</updated>
   <id>http://xadillax.github.io/programming/2013/07/15/javascript-in-function-this-pointer-repoint</id>
   <content type="html">&lt;p&gt;最近在写&lt;strong&gt;NBUT Virtual Judge&lt;/strong&gt;的内核框架，用的又是Node.JS了，把它当作一个本地运行的脚本不断进行轮询。&lt;/p&gt;
&lt;p&gt;众所周知JS中的一个精髓就是&lt;strong&gt;异步回调&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以在我自己写的框架中也经常会出现类似于下面的代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;总而言之就是写一个函数，这个函数将会调用一个回调函数。&lt;/p&gt;
&lt;p&gt;那么如果我们想在&lt;code&gt;function&lt;/code&gt;中也用&lt;code&gt;this&lt;/code&gt;来指代这个&lt;code&gt;foo&lt;/code&gt;对象该怎么办呢？&lt;/p&gt;
&lt;p&gt;结果还是IRC有用。本人跑Node.JS的IRC上问了这个问题，结果有人就这样回复我了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;13:07 &amp;lt; shama&amp;gt; xadillax: foo(a, b callback.bind(foo))&lt;/p&gt;
&lt;p&gt;13:10 &amp;lt; olalonde&amp;gt; foo (a, b fn) { fn = fn.bind(this); …. }&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后还很热心地给了我个网址：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&lt;/p&gt;
&lt;p&gt;总之最后得出的结论就是说：&lt;/p&gt;
&lt;p&gt;你只要给你的callback函数指定一个this指针即可。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样就能在回调函数中使用&lt;code&gt;foo&lt;/code&gt;来作为其&lt;code&gt;this&lt;/code&gt;指针了。&lt;/p&gt;
</content>
 </entry>
 
 
</feed>